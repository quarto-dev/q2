---
title: "Source Location Tracking"
---

## Overview

`quarto-markdown` tracks the exact source location of every element in the parsed AST (Abstract Syntax Tree). This enables:

- **Precise error reporting**: Show users exactly where syntax errors occur
- **IDE features**: Support go-to-definition, find-references, and refactoring
- **Source mapping**: Map generated output back to original source
- **Transformation tracking**: Understand how content was processed through multiple stages

Unlike traditional Markdown parsers that discard location information, `quarto-markdown` preserves the complete provenance chain showing how each piece of text was extracted, transformed, and combined.

## Architecture

The source tracking system has three main components:

### 1. SourceInfo Data Structure

Located in the `quarto-source-map` crate, `SourceInfo` is an enum that represents how a piece of text relates to its original source:

```rust
enum SourceInfo {
    Original {
        file_id: FileId,
        start_offset: usize,
        end_offset: usize,
    },
    Substring {
        parent: Rc<SourceInfo>,
        start_offset: usize,
        end_offset: usize,
    },
    Concat {
        pieces: Vec<SourcePiece>,
    },
}
```

- **Original**: Text directly from a source file
- **Substring**: Text extracted from a parent source (e.g., YAML value from frontmatter)
- **Concat**: Multiple sources joined together (e.g., adjacent text nodes)

### 2. Transformation Chains

SourceInfo objects form parent-child chains that record the complete transformation history:

```
Original file (bytes 0-100)
  ↓ Extract YAML frontmatter (bytes 4-80)
    ↓ Parse YAML value (bytes 20-40 within frontmatter)
      ↓ Parse inline markdown within value
```

Each step maintains precise offset information, allowing the system to map any point in the processed text back to the original source location.

### 3. Efficient Serialization

When writing JSON output, source information is serialized using a **pool-and-reference** system:

- All unique SourceInfo objects are stored once in a pool
- AST nodes reference pool entries by ID
- Shared sources (e.g., siblings in YAML) reuse the same pool entry
- Achieves ~93% size reduction compared to inline serialization

## Key Features

### Byte Offset Based

SourceInfo stores byte offsets, not line/column positions. Row and column information is computed on-demand using line break indices. This approach:

- Keeps the core data structure minimal
- Makes offset arithmetic fast and simple
- Defers UTF-8 processing until needed

### Reference Counted Sharing

Parent SourceInfo objects are wrapped in `Rc<SourceInfo>`, allowing multiple children to share the same parent without duplication. This is crucial for performance when parsing documents with many sibling elements (like YAML metadata).

### Topological Ordering

The serialization system maintains topological order: parents always appear before children in the pool. This ensures:

- No forward references when deserializing
- Simple validation against circular references
- Efficient pool building via depth-first traversal

## Documentation Sections

- [**JSON Format**](json.qmd) - Detailed specification of the JSON serialization format
- [**Architecture**](architecture.qmd) - Implementation details and design decisions

## Use Cases

### Error Reporting

When a syntax error occurs, the parser can show:

```
Error: Invalid YAML value
  ┌─ example.qmd:3:10
  │
3 │ title: [broken
  │          ^^^^^^ Expected closing bracket
```

The error points to the exact location in the original file, even though the YAML was extracted and processed separately.

### IDE Integration

Language servers can use source locations to:

- Jump to definition of cross-references
- Find all usages of a citation key
- Refactor heading IDs across documents
- Provide hover information with source context

### Debugging

When inspecting the AST, developers can trace any node back to its original source:

```json
{
  "t": "Str",
  "c": "Hello",
  "s": 42
}
```

Pool entry 42 reveals this text came from bytes 10-15 of the YAML frontmatter, which itself came from bytes 4-80 of the original file.

## Performance

The source tracking system is designed for minimal overhead:

- **Memory**: Rc-based sharing keeps memory usage proportional to unique sources, not AST size
- **Speed**: Offset arithmetic is fast; line/column conversion only happens when needed
- **Serialization**: Pool-based JSON is ~93% smaller than naive inline approach

For typical documents with metadata, the source tracking adds less than 10% to parse time while providing complete provenance information.
