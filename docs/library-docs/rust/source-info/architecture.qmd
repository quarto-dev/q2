---
title: "Architecture & Implementation"
---

## Overview

This document describes the technical implementation of source location tracking in `quarto-markdown`, including design decisions, performance characteristics, and implementation details.

## Core Data Structure

### SourceInfo Enum

Located in `crates/quarto-source-map/src/source_info.rs`:

```rust
pub enum SourceInfo {
    Original {
        file_id: FileId,
        start_offset: usize,
        end_offset: usize,
    },
    Substring {
        parent: Rc<SourceInfo>,
        start_offset: usize,
        end_offset: usize,
    },
    Concat {
        pieces: Vec<SourcePiece>,
    },
}
```

### Design Decisions

#### Why Byte Offsets Instead of Line/Column?

**Decision**: Store only byte offsets, compute line/column on demand

**Rationale**:
1. **Simplicity**: Offset arithmetic is trivial (add/subtract integers)
2. **Performance**: No UTF-8 processing during parsing
3. **Memory**: Smaller footprint (2 usizes vs 6 usizes)
4. **Consistency**: Offsets never become invalid when file changes

**Line/column conversion** uses binary search on line break indices:

```rust
fn offset_to_location(&self, offset: usize) -> Option<Location> {
    let line = self.line_breaks.partition_point(|&lb| lb < offset);
    let line_start = if line == 0 { 0 } else { self.line_breaks[line - 1] + 1 };
    let column = offset - line_start;
    Some(Location { offset, row: line, column })
}
```

Time complexity: O(log n) where n = number of lines (typically < 10,000)

#### Why Rc Instead of Arc?

**Decision**: Use `Rc<SourceInfo>` for parent references

**Rationale**:
1. **Single-threaded parsing**: The parser is not concurrent
2. **Performance**: Rc is faster than Arc (no atomic operations)
3. **Simplicity**: No need for Sync/Send bounds

**Implication**: SourceInfo is not Send/Sync. For multi-threaded scenarios, convert to an alternative representation.

#### Why Not Box?

**Considered**: `Box<SourceInfo>` instead of `Rc<SourceInfo>`

**Rejected because**:
- Box doesn't support sharing
- Siblings would need separate copies of the parent chain
- Memory usage would be O(n × depth) instead of O(unique nodes)

**Example**:
```rust
// With Rc: All siblings share one parent
let parent = Rc::new(SourceInfo::Original { ... });
let child1 = SourceInfo::Substring { parent: Rc::clone(&parent), ... };
let child2 = SourceInfo::Substring { parent: Rc::clone(&parent), ... };
// Memory: 1 parent + 2 children

// With Box: Each child needs its own parent copy
let child1 = SourceInfo::Substring { parent: Box::new(parent.clone()), ... };
let child2 = SourceInfo::Substring { parent: Box::new(parent.clone()), ... };
// Memory: 3 parents + 2 children (parent duplicated!)
```

## Serialization

### Pool Builder

Located in `crates/quarto-markdown-pandoc/src/writers/json.rs:108-230`

The serializer uses **pointer-based deduplication**:

```rust
struct SourceInfoSerializer {
    pool: Vec<SerializableSourceInfo>,
    id_map: HashMap<*const SourceInfo, usize>,
}
```

**Key insight**: Multiple Rc pointers to the same data have the same address:

```rust
let parent = Rc::new(SourceInfo::Original { ... });
let child1 = Rc::clone(&parent);
let child2 = Rc::clone(&parent);

assert_eq!(
    &*child1 as *const SourceInfo,
    &*child2 as *const SourceInfo
);
```

### Interning Algorithm

```rust
fn intern(&mut self, source_info: &SourceInfo) -> usize {
    let ptr = source_info as *const SourceInfo;

    // Check if already interned
    if let Some(&id) = self.id_map.get(&ptr) {
        return id;
    }

    // Recursively intern parents first (depth-first)
    let mapping = match source_info {
        SourceInfo::Substring { parent, .. } => {
            let parent_id = self.intern(parent);  // Recurse!
            SerializableSourceMapping::Substring { parent_id }
        }
        // ... other cases
    };

    // Add to pool after parents
    let id = self.pool.len();
    self.pool.push(SerializableSourceInfo { id, mapping, ... });
    self.id_map.insert(ptr, id);

    id
}
```

**Properties**:
1. **Depth-first traversal**: Parents interned before children (topological order guaranteed)
2. **Deduplication**: Same Rc pointer → same ID
3. **Linear time**: Each SourceInfo visited exactly once

### Topological Order Guarantee

The depth-first traversal naturally produces topological order:

```
Process: child
  → Intern parent (if not already)
    → Intern grandparent (if not already)
      → ... (recurse to root)
  → After parents are in pool, add child

Result: [grandparent, parent, child]
```

No explicit topological sort needed!

## Deserialization

### Pool Reconstruction

Located in `crates/quarto-markdown-pandoc/src/readers/json.rs:67-304`

```rust
struct SourceInfoDeserializer {
    pool: Vec<quarto_source_map::SourceInfo>,
}

impl SourceInfoDeserializer {
    fn new(pool_json: &Value) -> Result<Self> {
        let mut pool = Vec::new();

        for (current_index, item) in pool_array.iter().enumerate() {
            let parent_id = extract_parent_id(item);

            // Validate topological order
            if parent_id >= current_index {
                return Err(CircularSourceInfoReference(parent_id));
            }

            // Parent guaranteed to exist (already processed)
            let parent = pool[parent_id].clone();

            pool.push(SourceInfo::Substring {
                parent: Rc::new(parent),
                ...
            });
        }

        Ok(SourceInfoDeserializer { pool })
    }
}
```

**Properties**:
1. **Single pass**: Process pool entries sequentially
2. **Validation**: Reject forward references immediately
3. **No graph algorithms**: Linear time, no complex data structures

## Performance Analysis

### Memory Usage

**Per AST node**:
- 1 pointer to SourceInfo (8 bytes on 64-bit)
- SourceInfo shared via Rc (reference counted)

**Per unique SourceInfo**:
- Original: 24 bytes (file_id + 2 offsets)
- Substring: 32 bytes (Rc + 2 offsets)
- Concat: 24 + 24 × pieces (Vec overhead + pieces)

**Typical document** (1000 AST nodes, 50 unique sources):
- AST pointers: 8 KB
- SourceInfo objects: ~1.5 KB
- Total: ~10 KB

**Without pooling** (naive duplication):
- 1000 AST nodes × 5 levels deep × 32 bytes = 160 KB
- **16× larger**

### Serialization Performance

**Writer** (`SourceInfoSerializer::intern`):
- O(1) HashMap lookup per intern call
- O(n) total where n = unique SourceInfo objects
- Depth-first traversal visits each node once

**Typical document** (5000 AST nodes, 200 unique sources):
- 200 intern calls
- 200 HashMap insertions
- ~0.1ms overhead

**Bottleneck**: Not source tracking, but serde JSON serialization

### Deserialization Performance

**Reader** (`SourceInfoDeserializer::new`):
- O(n) single-pass array iteration
- O(1) array access for parent lookup
- No complex graph algorithms

**Typical document** (200 pool entries):
- 200 array iterations
- ~0.05ms overhead

**Bottleneck**: Not source tracking, but serde JSON parsing

### JSON Size

**Measurements** (100 YAML siblings example):

| Format | Size | Blowup |
|--------|------|--------|
| Original QMD | 2,031 bytes | 1.00× |
| Inline SourceInfo | 103,677 bytes | 51.05× |
| Pool-based | 7,200 bytes | 3.54× |

**Reduction**: 93% smaller than inline (103 KB → 7 KB)

**Remaining overhead**:
- JSON syntax: `{"r":[`, `],"t":`, etc.
- Numbers as strings: `123` → `"123"` in some JSON encoders
- Pool array wrapper: `"sourceInfoPool":[...]`

Could be further reduced with binary format (MessagePack, CBOR), but JSON is human-readable and debuggable.

## Design Patterns

### Transformation Chains

SourceInfo forms immutable linked lists via Rc:

```
Original (file.qmd, bytes 0-100)
  └─ Substring (YAML frontmatter, bytes 4-80)
       ├─ Substring (title value, bytes 10-20)
       ├─ Substring (author value, bytes 25-35)
       └─ Substring (date value, bytes 40-50)
```

**Properties**:
- **Immutable**: Once created, SourceInfo never changes
- **Persistent**: Adding a new child doesn't modify the parent
- **Shared**: Siblings share the same parent Rc

This is a **persistent data structure** pattern common in functional programming.

### Builder Pattern

The serializer follows the Builder pattern:

```rust
let mut serializer = SourceInfoSerializer::new();

// Accumulate state
write_meta(&meta, &mut serializer);   // Interns sources as side effect
write_blocks(&blocks, &mut serializer);

// Extract result
let pool = serializer.pool;
```

**Benefits**:
- Separation of traversal (writing AST) from pooling logic
- Automatic deduplication without explicit coordination
- Single responsibility: serializer only manages the pool

## Edge Cases

### Empty Pool

**Case**: Document with no source information

**Handling**:
```json
{
  "astContext": {
    "files": []
    // sourceInfoPool omitted when empty
  }
}
```

Parser creates `SourceInfoDeserializer::empty()` when pool is missing.

### Circular References

**Case**: Malformed JSON with forward references

**Example**:
```json
[
  {"r": [0, 10], "t": 1, "d": 1},   // ID 0 references ID 1
  {"r": [0, 20], "t": 0, "d": 0}    // ID 1
]
```

**Detection**: `parent_id >= current_index` check

**Error**:
```
Error: Circular or forward reference in sourceInfoPool
  Entry 0 references parent 1, but 1 >= 0 (forward reference)
```

### Deep Nesting

**Case**: Deeply nested YAML (10+ levels)

**Impact**:
- Depth-first intern recursion: O(depth) stack frames
- Pool size: O(depth) for the chain
- No performance problem unless depth > 1000

**Typical maximum**: 5-7 levels in real documents

### Concat Edge Cases

**Empty concat**:
```json
{"r": [0, 0], "t": 2, "d": []}
```

Valid but unusual (represents empty text from concatenation).

**Single-piece concat**:
```json
{"r": [0, 5], "t": 2, "d": [[0, 0, 5]]}
```

Valid but wasteful (should just reference source 0 directly). The serializer avoids creating these.

## Future Optimizations

### Range Pooling

**Idea**: Deduplicate Range objects too

**Current**:
```json
{"r": [0, 10], "t": 0, "d": 0}
{"r": [0, 10], "t": 0, "d": 1}  // Same range, different file
```

**With range pool**:
```json
{
  "rangePool": [
    [0, 10]   // Range ID 0
  ],
  "sourceInfoPool": [
    {"r": 0, "t": 0, "d": 0},
    {"r": 0, "t": 0, "d": 1}
  ]
}
```

**Estimated savings**: 10-20% additional reduction

**Complexity**: Requires second HashMap for range deduplication

### Binary Format

**Idea**: Use MessagePack or CBOR instead of JSON

**Benefits**:
- Type codes as bytes, not strings
- Integers as varints, not text
- No string escaping

**Estimated savings**: 30-50% smaller than compact JSON

**Tradeoff**: Not human-readable, harder to debug

### Compression

**Idea**: Use gzip/brotli compression

**Benefits**:
- Pool structure compresses well (lots of repetition)
- Transparent to JSON format

**Estimated savings**: 60-80% with gzip

**Tradeoff**: Compression/decompression overhead, not inspectable without decompressing

## Testing Strategy

### Unit Tests

Located in `crates/quarto-markdown-pandoc/src/writers/json.rs:1175-1497`

**Coverage**:
- Original interning
- Substring with parent reference
- Siblings sharing parent (deduplication test)
- Deep nesting (5+ levels)
- Concat with multiple pieces
- Rc-based deduplication

**Key test**:
```rust
#[test]
fn test_source_info_pool_deduplication() {
    let parent = Rc::new(SourceInfo::Original { ... });
    let child1 = SourceInfo::Substring { parent: Rc::clone(&parent), ... };
    let child2 = SourceInfo::Substring { parent: Rc::clone(&parent), ... };

    serializer.intern(&child1);
    serializer.intern(&child2);

    // Parent should appear only once in pool
    assert_eq!(serializer.pool.len(), 3);  // 1 parent + 2 children
}
```

### Roundtrip Tests

**Approach**: QMD → JSON → deserialize → verify structure

**Validates**:
- Serialization produces valid pool
- Deserialization reconstructs equivalent SourceInfo
- No information loss

## Implementation Checklist

For other language implementations:

- [ ] Parse pool as array (index = ID)
- [ ] Validate topological order (parent_id < current_index)
- [ ] Support types 0, 1, 2 (Original, Substring, Concat)
- [ ] Handle type 3 as deprecated (read as Substring)
- [ ] Support both 2-element and 6-element range arrays
- [ ] Reject forward references with clear error
- [ ] Handle missing sourceInfoPool gracefully
- [ ] Binary search for offset-to-line conversion
- [ ] Preserve Rc-sharing semantics when possible

## Further Reading

- [Source Tracking Overview](index.qmd) - High-level concepts
- [JSON Format Specification](json.qmd) - Detailed format reference
- [JSON Writer](../writers/json.qmd) - Using the JSON output
