This repository contains a Rust library and binary crate that converts Markdown text to
Pandoc's AST representation using custom tree-sitter grammars for Markdown.

The Markdown variant in this repository is close but **not identical** to Pandoc's grammar.

Crucially, this converter is willing and able to emit error messages when Markdown constructs
are written incorrectly on disk.

This tree-sitter setup is somewhat unique because Markdown requires a two-step process:
one tree-sitter grammar to establish the block structure, and another tree-sitter grammar
to parse the inline structure within each block.

As a result, in this repository all traversals of the tree-sitter data structure
need to be done with the traversal helpers in traversals.rs.

## Best practices in this repo

- If you want to create a test file, do so in the `tests/` directory.
- **IMPORTANT**: When making changes to the code, ALWAYS run both `cargo check` AND `cargo test` to ensure changes compile and don't affect behavior. The test suite is fast enough to run after each change. Never skip running `cargo test` - it must always be executed together with `cargo check`.
- **CRITICAL**: Do NOT assume changes are safe if ANY tests fail, even if they seem unrelated. Some tests require pandoc to be properly installed to pass. Always ensure ALL tests pass before and after changes.

## **CRITICAL**: HOW TO DO CODING WORK IN THIS REPO

Whenever you start working on a coding task, follow these steps:

- Make a plan to yourself.
  - The plan should include adding appropriate tests to the test suite.
  - **FIRST**: Write the test that you think should fail
  - **SECOND**: Run ONLY that test and verify it fails with the expected error
  - **THIRD**: Implement the fix
  - **FOURTH**: Run the test again and verify it now passes
- Work on the plan item by item.
- You are not done until the test you wrote passes.
- You are not done until the test you wrote is integrated to our test suite.
- If you run out of ideas and still can't make the test pass, do not erase the test. Report back to me and we will work on it together.
- If in the process of writing tests you run into an unexpected parse error, store it in a separate file and report it to me. We're still improving the parser and it's possible that you will run into bugs.

## BEFORE YOU IMPLEMENT ANY BUG FIX - MANDATORY CHECKLIST

Before implementing ANY bug fix, you MUST complete this checklist in order:

- [ ] Have you written the test?
- [ ] Have you run the test and confirmed it fails?
- [ ] Have you verified the failure is exactly what you expected?
- [ ] Only after all three above are complete: proceed with implementation

This is non-negotiable. Do not skip this process.

# Error messages

The error message infrastructure is based on Clinton Jeffery's TOPLAS 2003 paper "Generating Syntax Errors from Examples". You don't need to read the entire paper to understand what's happening. The abstract of the paper is:

LR parser generators are powerful and well-understood, but the parsers they generate are not suited to provide good error messages. Many compilers incur extensive modifications to the source grammar to produce useful syntax error messages. Interpreting the parse state (and input token) at the time of error is a nonintrusive alternative that does not entangle the error recovery mechanism in error message production. Unfortunately, every change to the grammar may significantly alter the mapping from parse states to diagnostic messages, creating a maintenance problem. Merr is a tool that allows a compiler writer to associate diagnostic messages with syntax errors by example, avoiding the need to add error productions to the grammar or interpret integer parse states. From a specification of errors and messages, Merr runs the compiler on each example error to obtain the relevant parse state and input token, and generates a yyerror() function that maps parse states and input tokens to diagnostic messages. Merr enables useful syntax error messages in LR-based compilers in a manner that is robust in the presence of grammar changes.

We're not using "merr" here; we are merely implementing the same technique.

## Creating error examples

The corpus of error examples in this repository uses a consolidated format where each error code has a single JSON file with multiple test cases.

### Error Corpus Structure

- **Source files**: `resources/error-corpus/Q-*.json` - One file per error code
- **Generated files**: `resources/error-corpus/case-files/*.qmd` - Test case files (generated by build script)
- **Autogen table**: `resources/error-corpus/_autogen-table.json` - Parser state mappings (generated)

### JSON Format

Each `Q-*.json` file contains:
- Error metadata (code, title, message, notes) - appears once
- `cases` array - multiple test scenarios that trigger the error in different contexts

Example structure:
```json
{
  "code": "Q-2-10",
  "title": "Error Title",
  "message": "Error message text",
  "notes": [
    {
      "message": "Additional context",
      "label": "capture-label",
      "noteType": "simple"
    }
  ],
  "cases": [
    {
      "name": "simple",
      "description": "Description of this test case",
      "content": "test content that triggers the error",
      "captures": [
        {
          "label": "capture-label",
          "row": 0,
          "column": 5,
          "size": 1
        }
      ]
    },
    {
      "name": "in-emphasis",
      "description": "Error inside emphasis markup",
      "content": "*test content*",
      "captures": [...]
    }
  ]
}
```

### Adding New Error Cases

To add a new test case to an existing error:

1. Edit the appropriate `resources/error-corpus/Q-*.json` file
2. Add a new object to the `cases` array with:
   - `name`: kebab-case identifier (e.g., "in-link-text")
   - `description`: Human-readable explanation
   - `content`: The qmd text that triggers the error
   - `captures`: Array of capture coordinates (row, column, size, label)
3. Run `./scripts/build_error_table.ts` to regenerate the error table
4. Test your changes with `cargo test`

### Adding New Error Codes

To add a completely new error code:

1. Create a new `resources/error-corpus/Q-*.json` file following the format above
2. Add at least one case (usually named "simple")
3. Run `./scripts/build_error_table.ts`
4. The build script will:
   - Generate `.qmd` files in `case-files/` directory
   - Run the parser to capture error states
   - Update `_autogen-table.json` with the (state, sym) mappings

## Recompiling

After changing any `resources/error-corpus/Q-*.json` files, run `./scripts/build_error_table.ts`. The script:
1. Clears and regenerates `resources/error-corpus/case-files/` directory
2. Creates `.qmd` files for each test case
3. Runs the parser to capture error states
4. Updates `_autogen-table.json`
5. Rebuilds the Rust code with the new table

The script is executable with a deno hashbang line. Deno is installed on the environment.

## Binary usage

The `quarto-markdown-pandoc` binary accepts the following options:
- `-t, --to <TO>`: Output format (default: native)
- `-f, --from <FROM>`: Input format (default: qmd)
- `-v, --verbose`: Verbose output
- `-i, --input <INPUT>`: Input file (default: stdin)
- `--loose`: Loose parsing mode
- `--json-errors`: Output errors as JSON
- `-h, --help`: Show help

## Instructions

- In this repository, "qmd" means "quarto markdown", the dialect of markdown we are developing. Although we aim to be largely compatible with Pandoc, it is not necessarily the case that a discrepancy in the behavior is a bug.
- The qmd format only supports the inline syntax for a link [link](./target.html), and not the reference-style syntax [link][1].
- Always strive for test documents as small as possible. Prefer a large number of small test documents instead of small number of large documents.
- When fixing bugs, always try to isolate and fix one bug at a time.
- **CRITICAL - TEST FIRST**: When fixing bugs using tests, you MUST run the failing test BEFORE implementing any fix. This is non-negotiable. Verify the test fails in the expected way, then implement the fix, then verify the test passes.
- If you need to fix parser bugs, you will find use in running the application with "-v", which will provide a large amount of information from the tree-sitter parsing process, including a print of the concrete syntax tree out to stderr.
- use "cargo run --" instead of trying to find the binary location, which will often be outside of this crate.
- If you need to fix parser bugs, you will find use in running the application with "-v", which will provide a large amount of information from the tree-sitter parsing process, including a print of the concrete syntax tree out to stderr.
- When fixing inconsistency bugs, use `pandoc -t json -i <input_file>` to get Pandoc's output, and `cargo run -- -t json -i <input_file>` to get our output.
- **When fixing roundtripping bugs**: FIRST add the failing test to `tests/roundtrip_tests/qmd-json-qmd`, run it to verify it fails with the expected output, THEN implement the fix, THEN verify the test passes.
- When I say "@doit", I mean "create a plan, and work on it item by item."
- When you're done editing a Rust file, run `cargo fmt` on it.
- If I ask you to write notes to yourself, do it in markdown and write the output in the `claude-notes` directory.
- If you need more information on the syntax differences, you are allowed to read the [syntax notes](../../docs/syntax-notes.md) file.