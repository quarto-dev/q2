//! Build script to generate CSL conformance tests.
//!
//! This script scans test-data/csl-suite/ for test files and generates
//! test functions. Tests not listed in tests/enabled_tests.txt are
//! generated with #[ignore].

use std::collections::HashSet;
use std::env;
use std::fs;
use std::path::Path;

fn main() {
    println!("cargo:rerun-if-changed=tests/enabled_tests.txt");
    println!("cargo:rerun-if-changed=test-data/csl-suite");

    let out_dir = env::var("OUT_DIR").unwrap();
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();

    let test_dir = Path::new(&manifest_dir).join("test-data/csl-suite");
    let enabled_file = Path::new(&manifest_dir).join("tests/enabled_tests.txt");

    // Load enabled tests
    let enabled_tests = load_enabled_tests(&enabled_file);

    // Collect test files
    let mut test_files: Vec<_> = fs::read_dir(&test_dir)
        .expect("Failed to read test-data/csl-suite")
        .filter_map(|entry| entry.ok())
        .filter(|entry| {
            entry
                .path()
                .extension()
                .map(|ext| ext == "txt")
                .unwrap_or(false)
        })
        .collect();

    // Sort for deterministic output
    test_files.sort_by_key(|e| e.path());

    // Generate test functions
    let mut generated = String::new();
    generated.push_str("// Auto-generated by build.rs - do not edit\n\n");

    for entry in &test_files {
        let path = entry.path();
        let file_name = path.file_stem().unwrap().to_str().unwrap();
        let test_name = sanitize_test_name(file_name);

        // Case-insensitive comparison: compare lowercase file name to enabled tests
        let ignored = if enabled_tests.contains(&file_name.to_lowercase()) {
            ""
        } else {
            "#[ignore]\n"
        };

        // Use CARGO_MANIFEST_DIR for absolute path at compile time
        generated.push_str(&format!(
            r#"{}#[test]
fn csl_{}() {{
    let content = include_str!(concat!(env!("CARGO_MANIFEST_DIR"), "/test-data/csl-suite/{}.txt"));
    let test = CslTest::parse("{}", content).expect("Failed to parse test file");
    if let Err(e) = run_csl_test(&test) {{
        panic!("{{}}", e);
    }}
}}

"#,
            ignored, test_name, file_name, file_name
        ));
    }

    let out_path = Path::new(&out_dir).join("generated_csl_tests.rs");
    fs::write(&out_path, generated).expect("Failed to write generated tests");

    // Also generate a count file for reference
    let count_info = format!(
        "// Test counts: {} total, {} enabled\n",
        test_files.len(),
        enabled_tests.len()
    );
    let count_path = Path::new(&out_dir).join("test_counts.txt");
    fs::write(&count_path, count_info).expect("Failed to write test counts");
}

/// Load enabled test names from the manifest file.
/// Test names are normalized to lowercase for case-insensitive matching.
fn load_enabled_tests(path: &Path) -> HashSet<String> {
    if !path.exists() {
        return HashSet::new();
    }

    fs::read_to_string(path)
        .unwrap_or_default()
        .lines()
        .map(|line| line.trim())
        .filter(|line| !line.is_empty() && !line.starts_with('#'))
        .map(|s| s.to_lowercase())
        .collect()
}

/// Sanitize a test name for use as a Rust identifier.
fn sanitize_test_name(name: &str) -> String {
    name.chars()
        .map(|c| if c.is_alphanumeric() { c } else { '_' })
        .collect::<String>()
        .to_lowercase()
}
