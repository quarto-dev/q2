//! CSL conformance test suite.
//!
//! This file includes auto-generated tests from the CSL test suite.
//! Tests are generated by build.rs from files in test-data/csl-suite/.
//!
//! Usage:
//!   cargo nextest run -p quarto-citeproc  # Run enabled tests only
//!   cargo nextest run -p quarto-citeproc -- --ignored  # Run pending tests only
//!   cargo nextest run -p quarto-citeproc -- --include-ignored  # Run all tests
//!
//! To enable a test, add its name to tests/enabled_tests.txt

use std::collections::HashMap;

use quarto_citeproc::output::{
    move_punctuation_inside_quotes, render_blocks_to_csl_html_with_locale,
    render_inlines_to_csl_html_with_locale,
};
use quarto_citeproc::{Citation, CitationItem, Processor, Reference};
use quarto_csl::parse_csl;

// ============================================================================
// Test File Parser
// ============================================================================

/// A parsed CSL conformance test.
#[derive(Debug, Clone)]
pub struct CslTest {
    /// Test name (from filename)
    pub name: String,
    /// Mode: "citation" or "bibliography"
    pub mode: String,
    /// Expected result
    pub result: String,
    /// CSL style XML
    pub csl: String,
    /// Input references (JSON)
    pub input: String,
    /// Citation items (JSON), if present
    pub citation_items: Option<String>,
    /// Citations (JSON), if present
    pub citations: Option<String>,
    /// CSL version
    pub version: Option<String>,
}

impl CslTest {
    /// Parse a test file's contents.
    pub fn parse(name: &str, content: &str) -> Result<Self, String> {
        let sections = parse_sections(content);

        let mode = sections
            .get("mode")
            .ok_or("Missing MODE section")?
            .trim()
            .to_string();

        let result = sections
            .get("result")
            .ok_or("Missing RESULT section")?
            .to_string();

        let csl = sections
            .get("csl")
            .ok_or("Missing CSL section")?
            .to_string();

        let input = sections
            .get("input")
            .ok_or("Missing INPUT section")?
            .to_string();

        Ok(CslTest {
            name: name.to_string(),
            mode,
            result,
            csl,
            input,
            citation_items: sections.get("citation-items").cloned(),
            citations: sections.get("citations").cloned(),
            version: sections.get("version").map(|s| s.trim().to_string()),
        })
    }
}

/// Parse sections from test file content.
fn parse_sections(content: &str) -> HashMap<String, String> {
    // Strip UTF-8 BOM if present
    let content = content.strip_prefix('\u{feff}').unwrap_or(content);

    let mut sections = HashMap::new();
    let mut current_section: Option<String> = None;
    let mut current_content = String::new();

    for line in content.lines() {
        // Check for section start: >>===== NAME =====>> or >>== NAME ==>>
        // (test files use varying numbers of = signs, some have only 2)
        if line.starts_with(">>") && line.contains("==") && line.ends_with(">>") {
            // Save previous section if any
            if let Some(ref name) = current_section {
                sections.insert(name.clone(), current_content.trim_end().to_string());
            }

            // Extract section name
            let name = extract_section_name(line);
            current_section = Some(name.to_lowercase());
            current_content = String::new();
        }
        // Check for section end: <<===== NAME =====<< or <<== NAME ==<<
        else if line.starts_with("<<") && line.contains("==") && line.ends_with("<<") {
            if let Some(ref name) = current_section {
                sections.insert(name.clone(), current_content.trim_end().to_string());
            }
            current_section = None;
            current_content = String::new();
        }
        // Content line
        else if current_section.is_some() {
            if !current_content.is_empty() {
                current_content.push('\n');
            }
            current_content.push_str(line);
        }
    }

    sections
}

/// Extract section name from a marker line like ">>===== MODE =====>>".
fn extract_section_name(line: &str) -> String {
    // Remove >> prefix and >> suffix, then extract name from between = signs
    let trimmed = line
        .trim_start_matches('>')
        .trim_end_matches('>')
        .trim_start_matches('<')
        .trim_end_matches('<');

    // Find the name between the = signs
    let parts: Vec<&str> = trimmed.split('=').collect();

    // The name should be in the middle, surrounded by = signs
    for part in parts {
        let part = part.trim();
        if !part.is_empty() {
            return part.to_string();
        }
    }

    String::new()
}

// ============================================================================
// Test Runner
// ============================================================================

/// Run a CSL conformance test and return the result.
pub fn run_csl_test(test: &CslTest) -> Result<(), String> {
    // Parse the CSL style
    let style = parse_csl(&test.csl).map_err(|e| format!("CSL parse error: {:?}", e))?;

    // Create processor
    let mut processor = Processor::new(style);

    // Parse and add references
    let references: Vec<Reference> =
        serde_json::from_str(&test.input).map_err(|e| format!("Input JSON error: {}", e))?;

    for reference in references.iter() {
        processor.add_reference(reference.clone());
    }

    // Build citations
    let citations = build_citations(test, &references)?;

    // Check locale options for post-processing
    let punct_in_quote = processor.punctuation_in_quote();
    let quote_config = processor.get_quote_config();

    // Check if this is a complex CITATIONS format test (needs incremental output)
    let is_incremental = test.citations.is_some() && is_complex_citations_format(test);

    // Process based on mode
    let actual = match test.mode.as_str() {
        "citation" => {
            // Use disambiguation-aware processing for all citations
            let output_asts = processor
                .process_citations_with_disambiguation_to_outputs(&citations)
                .map_err(|e| format!("Citation error: {:?}", e))?;

            let outputs: Vec<String> = output_asts
                .into_iter()
                .map(|output_ast| {
                    // Apply locale post-processing on the Output AST
                    let processed = if punct_in_quote {
                        move_punctuation_inside_quotes(output_ast)
                    } else {
                        output_ast
                    };
                    let inlines = processed.to_inlines();
                    render_inlines_to_csl_html_with_locale(&inlines, &quote_config)
                })
                .collect();

            // Apply incremental output format if needed
            if is_incremental {
                format_incremental_output(&outputs)
            } else {
                outputs.join("\n")
            }
        }
        "bibliography" => {
            // Process citations first with disambiguation to assign initial citation numbers
            // and year suffixes. This is needed for citation-number sorting and disambiguation.
            if !citations.is_empty() {
                let _ = processor.process_citations_with_disambiguation_to_outputs(&citations);
            }

            // Use generate_bibliography_to_outputs to get entries in sorted order
            // with Output AST
            let entries = processor
                .generate_bibliography_to_outputs()
                .map_err(|e| format!("Bibliography error: {:?}", e))?;

            // Convert each entry through the new pipeline: Output → Blocks → CSL HTML
            // Using to_blocks() handles the display attribute for bibliography entries
            let outputs: Vec<String> = entries
                .into_iter()
                .map(|(_, output)| {
                    // Apply locale post-processing on the Output AST
                    let processed = if punct_in_quote {
                        move_punctuation_inside_quotes(output)
                    } else {
                        output
                    };
                    // Use to_blocks() to handle display attributes
                    let blocks = processed.to_blocks();
                    let html = render_blocks_to_csl_html_with_locale(&blocks, &quote_config);
                    format_bib_entry(&html)
                })
                .collect();
            format_bibliography(&outputs)
        }
        other => return Err(format!("Unknown mode: {}", other)),
    };

    // Compare with expected result
    let expected = &test.result;

    if actual == *expected {
        Ok(())
    } else {
        Err(format!(
            "Output mismatch:\n\n--- Expected ---\n{}\n\n--- Actual ---\n{}\n\n--- Diff ---\n{}",
            expected,
            actual,
            simple_diff(expected, &actual)
        ))
    }
}

/// Build citations from test data.
fn build_citations(test: &CslTest, references: &[Reference]) -> Result<Vec<Citation>, String> {
    // Check for explicit citations first (CITATIONS format)
    if let Some(ref citations_json) = test.citations {
        // Try to parse as the complex CITATIONS format first:
        // [[{citationID, citationItems, properties}, citations_pre, citations_post], ...]
        let raw: serde_json::Value = serde_json::from_str(citations_json)
            .map_err(|e| format!("Citations JSON error: {}", e))?;

        if let Some(outer_array) = raw.as_array() {
            // Check if this is the complex CITATIONS format by looking at the first element
            let is_complex_format = outer_array.first().is_some_and(|first| {
                // Complex format: first element is a 3-element array [citation_obj, pre, post]
                // where citation_obj has "citationItems" key
                if let Some(arr) = first.as_array() {
                    arr.first()
                        .and_then(|obj| obj.get("citationItems"))
                        .is_some()
                } else {
                    false
                }
            });

            if is_complex_format {
                return parse_complex_citations_format(outer_array);
            } else {
                // Simple format: [[{id: "ITEM-1"}], [{id: "ITEM-2"}]]
                return parse_simple_citations_format(outer_array);
            }
        }

        return Err("Citations must be an array".to_string());
    }

    // Check for citation-items
    if let Some(ref items_json) = test.citation_items {
        // Format: [[{"id": "ITEM-1"}, {"id": "ITEM-2"}]]
        let raw: Vec<Vec<serde_json::Value>> = serde_json::from_str(items_json)
            .map_err(|e| format!("Citation-items JSON error: {}", e))?;

        let mut citations = Vec::new();
        for cite_group in raw {
            let items: Vec<CitationItem> = cite_group
                .iter()
                .filter_map(parse_citation_item)
                .collect();

            if !items.is_empty() {
                citations.push(Citation {
                    items,
                    ..Default::default()
                });
            }
        }

        return Ok(citations);
    }

    // Default: create one citation with all references
    let items: Vec<CitationItem> = references
        .iter()
        .map(|r| CitationItem {
            id: r.id.clone(),
            ..Default::default()
        })
        .collect();

    Ok(vec![Citation {
        items,
        ..Default::default()
    }])
}

/// Parse the complex CITATIONS format used in CSL test suite.
/// Format: [[{citationID, citationItems, properties}, citations_pre, citations_post], ...]
fn parse_complex_citations_format(
    outer_array: &[serde_json::Value],
) -> Result<Vec<Citation>, String> {
    let mut citations = Vec::new();

    for entry in outer_array {
        let entry_array = entry.as_array().ok_or("CITATIONS entry must be an array")?;

        // First element is the citation object
        let citation_obj = entry_array
            .first()
            .ok_or("CITATIONS entry must have citation object")?;

        // Extract citationID
        let citation_id = citation_obj
            .get("citationID")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());

        // Extract noteIndex from properties
        let note_number = citation_obj
            .get("properties")
            .and_then(|p| p.get("noteIndex"))
            .and_then(|n| n.as_i64())
            .map(|n| n as i32);

        // Extract citationItems
        let citation_items_array = citation_obj
            .get("citationItems")
            .and_then(|v| v.as_array())
            .ok_or("CITATIONS entry must have citationItems array")?;

        let items: Vec<CitationItem> = citation_items_array
            .iter()
            .filter_map(parse_citation_item)
            .collect();

        if !items.is_empty() {
            citations.push(Citation {
                id: citation_id,
                note_number,
                items,
            });
        }
    }

    Ok(citations)
}

/// Parse the simple citations format: [[{id: "ITEM-1"}], [{id: "ITEM-2"}]]
fn parse_simple_citations_format(
    outer_array: &[serde_json::Value],
) -> Result<Vec<Citation>, String> {
    let mut citations = Vec::new();

    for cite_group in outer_array {
        let group_array = cite_group
            .as_array()
            .ok_or("Citation group must be an array")?;

        let items: Vec<CitationItem> = group_array
            .iter()
            .filter_map(parse_citation_item)
            .collect();

        if !items.is_empty() {
            citations.push(Citation {
                items,
                ..Default::default()
            });
        }
    }

    Ok(citations)
}

/// Check if a test uses the complex CITATIONS format (with citationItems nested structure).
fn is_complex_citations_format(test: &CslTest) -> bool {
    if let Some(ref citations_json) = test.citations
        && let Ok(raw) = serde_json::from_str::<serde_json::Value>(citations_json)
            && let Some(outer_array) = raw.as_array() {
                return outer_array.first().is_some_and(|first| {
                    if let Some(arr) = first.as_array() {
                        arr.first()
                            .and_then(|obj| obj.get("citationItems"))
                            .is_some()
                    } else {
                        false
                    }
                });
            }
    false
}

/// Format output with incremental citation markers.
/// Previous citations get `..[n]` prefix, last citation gets `>>[n]` prefix.
fn format_incremental_output(outputs: &[String]) -> String {
    if outputs.is_empty() {
        return String::new();
    }

    let last_idx = outputs.len() - 1;
    outputs
        .iter()
        .enumerate()
        .map(|(i, output)| {
            let marker = if i == last_idx { ">>" } else { ".." };
            format!("{}[{}] {}", marker, i, output)
        })
        .collect::<Vec<_>>()
        .join("\n")
}

/// Parse a single citation item from JSON.
fn parse_citation_item(v: &serde_json::Value) -> Option<CitationItem> {
    // Handle both string and integer IDs
    let id = match v.get("id")? {
        serde_json::Value::String(s) => s.clone(),
        serde_json::Value::Number(n) => n.to_string(),
        _ => return None,
    };

    Some(CitationItem {
        id,
        locator: v
            .get("locator")
            .and_then(|l| l.as_str())
            .map(|s| s.to_string()),
        label: v
            .get("label")
            .and_then(|l| l.as_str())
            .map(|s| s.to_string()),
        prefix: v
            .get("prefix")
            .and_then(|p| p.as_str())
            .map(|s| s.to_string()),
        suffix: v
            .get("suffix")
            .and_then(|s| s.as_str())
            .map(|s| s.to_string()),
        position: v.get("position").and_then(|p| p.as_i64()).map(|n| n as i32),
        ..Default::default()
    })
}

/// Format a bibliography entry with div wrapper.
fn format_bib_entry(entry: &str) -> String {
    // Different display attributes use different formatting:
    // - left-margin/right-inline: newline after opening, 4-space indent before content
    // - indent/block: content inline with opening, only newline before closing
    if entry.contains("class=\"csl-left-margin\"") || entry.contains("class=\"csl-right-inline\"") {
        // SecondFieldAlign style: newline and indent before inner divs
        format!("  <div class=\"csl-entry\">\n    {}\n  </div>", entry)
    } else if entry.contains("class=\"csl-indent\"") || entry.contains("class=\"csl-block\"") {
        // Block/indent style: content inline, newline before closing
        format!("  <div class=\"csl-entry\">{}\n  </div>", entry)
    } else {
        format!("  <div class=\"csl-entry\">{}</div>", entry)
    }
}

/// Format the complete bibliography with outer div.
fn format_bibliography(entries: &[String]) -> String {
    let mut output = String::from("<div class=\"csl-bib-body\">\n");
    for entry in entries {
        output.push_str(entry);
        output.push('\n');
    }
    output.push_str("</div>");
    output
}

/// Simple line-by-line diff for error messages.
fn simple_diff(expected: &str, actual: &str) -> String {
    let expected_lines: Vec<&str> = expected.lines().collect();
    let actual_lines: Vec<&str> = actual.lines().collect();

    let mut diff = String::new();
    let max_lines = expected_lines.len().max(actual_lines.len());

    for i in 0..max_lines {
        let exp = expected_lines.get(i).copied().unwrap_or("");
        let act = actual_lines.get(i).copied().unwrap_or("");

        if exp != act {
            diff.push_str(&format!("Line {}:\n", i + 1));
            diff.push_str(&format!("  - {}\n", exp));
            diff.push_str(&format!("  + {}\n", act));

            // Show byte-level differences if lines look similar
            let exp_bytes: Vec<u8> = exp.bytes().collect();
            let act_bytes: Vec<u8> = act.bytes().collect();
            if exp_bytes.len() != act_bytes.len() {
                diff.push_str(&format!(
                    "  Length differs: expected {} bytes, actual {} bytes\n",
                    exp_bytes.len(),
                    act_bytes.len()
                ));
            }
            // Find first differing byte
            for j in 0..exp_bytes.len().min(act_bytes.len()) {
                if exp_bytes[j] != act_bytes[j] {
                    diff.push_str(&format!(
                        "  First byte diff at position {}: expected 0x{:02x} ({:?}), actual 0x{:02x} ({:?})\n",
                        j,
                        exp_bytes[j],
                        char::from_u32(exp_bytes[j] as u32),
                        act_bytes[j],
                        char::from_u32(act_bytes[j] as u32)
                    ));
                    break;
                }
            }
        }
    }

    if diff.is_empty() {
        "No line differences (check trailing whitespace/newlines)".to_string()
    } else {
        diff
    }
}

// ============================================================================
// Generated Tests
// ============================================================================

// Include the generated tests
include!(concat!(env!("OUT_DIR"), "/generated_csl_tests.rs"));
