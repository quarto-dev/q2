//! CSL conformance test suite.
//!
//! This file includes auto-generated tests from the CSL test suite.
//! Tests are generated by build.rs from files in test-data/csl-suite/.
//!
//! Usage:
//!   cargo nextest run -p quarto-citeproc  # Run enabled tests only
//!   cargo nextest run -p quarto-citeproc -- --ignored  # Run pending tests only
//!   cargo nextest run -p quarto-citeproc -- --include-ignored  # Run all tests
//!
//! To enable a test, add its name to tests/enabled_tests.txt

use std::collections::HashMap;

use quarto_citeproc::{Citation, CitationItem, Processor, Reference};
use quarto_csl::parse_csl;

// ============================================================================
// Test File Parser
// ============================================================================

/// A parsed CSL conformance test.
#[derive(Debug, Clone)]
pub struct CslTest {
    /// Test name (from filename)
    pub name: String,
    /// Mode: "citation" or "bibliography"
    pub mode: String,
    /// Expected result
    pub result: String,
    /// CSL style XML
    pub csl: String,
    /// Input references (JSON)
    pub input: String,
    /// Citation items (JSON), if present
    pub citation_items: Option<String>,
    /// Citations (JSON), if present
    pub citations: Option<String>,
    /// CSL version
    pub version: Option<String>,
}

impl CslTest {
    /// Parse a test file's contents.
    pub fn parse(name: &str, content: &str) -> Result<Self, String> {
        let sections = parse_sections(content);

        let mode = sections
            .get("mode")
            .ok_or("Missing MODE section")?
            .trim()
            .to_string();

        let result = sections
            .get("result")
            .ok_or("Missing RESULT section")?
            .to_string();

        let csl = sections
            .get("csl")
            .ok_or("Missing CSL section")?
            .to_string();

        let input = sections
            .get("input")
            .ok_or("Missing INPUT section")?
            .to_string();

        Ok(CslTest {
            name: name.to_string(),
            mode,
            result,
            csl,
            input,
            citation_items: sections.get("citation-items").cloned(),
            citations: sections.get("citations").cloned(),
            version: sections.get("version").map(|s| s.trim().to_string()),
        })
    }
}

/// Parse sections from test file content.
fn parse_sections(content: &str) -> HashMap<String, String> {
    let mut sections = HashMap::new();
    let mut current_section: Option<String> = None;
    let mut current_content = String::new();

    for line in content.lines() {
        // Check for section start: >>===== NAME =====>> or >>==== NAME ====>>
        // (test files use varying numbers of = signs)
        if line.starts_with(">>") && line.contains("====") && line.ends_with(">>") {
            // Save previous section if any
            if let Some(ref name) = current_section {
                sections.insert(name.clone(), current_content.trim_end().to_string());
            }

            // Extract section name
            let name = extract_section_name(line);
            current_section = Some(name.to_lowercase());
            current_content = String::new();
        }
        // Check for section end: <<===== NAME =====<< or <<==== NAME ====<<
        else if line.starts_with("<<") && line.contains("====") && line.ends_with("<<") {
            if let Some(ref name) = current_section {
                sections.insert(name.clone(), current_content.trim_end().to_string());
            }
            current_section = None;
            current_content = String::new();
        }
        // Content line
        else if current_section.is_some() {
            if !current_content.is_empty() {
                current_content.push('\n');
            }
            current_content.push_str(line);
        }
    }

    sections
}

/// Extract section name from a marker line like ">>===== MODE =====>>".
fn extract_section_name(line: &str) -> String {
    // Remove >> prefix and >> suffix, then extract name from between = signs
    let trimmed = line
        .trim_start_matches('>')
        .trim_end_matches('>')
        .trim_start_matches('<')
        .trim_end_matches('<');

    // Find the name between the = signs
    let parts: Vec<&str> = trimmed.split('=').collect();

    // The name should be in the middle, surrounded by = signs
    for part in parts {
        let part = part.trim();
        if !part.is_empty() {
            return part.to_string();
        }
    }

    String::new()
}

// ============================================================================
// Test Runner
// ============================================================================

/// Run a CSL conformance test and return the result.
pub fn run_csl_test(test: &CslTest) -> Result<(), String> {
    // Parse the CSL style
    let style = parse_csl(&test.csl).map_err(|e| format!("CSL parse error: {:?}", e))?;

    // Create processor
    let mut processor = Processor::new(style);

    // Parse and add references
    let references: Vec<Reference> =
        serde_json::from_str(&test.input).map_err(|e| format!("Input JSON error: {}", e))?;

    for reference in references.iter() {
        processor.add_reference(reference.clone());
    }

    // Build citations
    let citations = build_citations(test, &references)?;

    // Process based on mode
    let actual = match test.mode.as_str() {
        "citation" => {
            let mut outputs = Vec::new();
            for citation in &citations {
                let output = processor
                    .process_citation(citation)
                    .map_err(|e| format!("Citation error: {:?}", e))?;
                outputs.push(output);
            }
            outputs.join("\n")
        }
        "bibliography" => {
            let mut outputs = Vec::new();
            for reference in &references {
                if let Some(output) = processor
                    .format_bibliography_entry(&reference.id)
                    .map_err(|e| format!("Bibliography error: {:?}", e))?
                {
                    outputs.push(format_bib_entry(&output));
                }
            }
            format_bibliography(&outputs)
        }
        other => return Err(format!("Unknown mode: {}", other)),
    };

    // Compare with expected result
    let expected = &test.result;

    if actual == *expected {
        Ok(())
    } else {
        Err(format!(
            "Output mismatch:\n\n--- Expected ---\n{}\n\n--- Actual ---\n{}\n\n--- Diff ---\n{}",
            expected,
            actual,
            simple_diff(expected, &actual)
        ))
    }
}

/// Build citations from test data.
fn build_citations(test: &CslTest, references: &[Reference]) -> Result<Vec<Citation>, String> {
    // Check for explicit citations first
    if let Some(ref citations_json) = test.citations {
        // Parse the citations JSON
        // Format: [[{"id": "ITEM-1"}], [{"id": "ITEM-2"}]]
        let raw: Vec<Vec<serde_json::Value>> = serde_json::from_str(citations_json)
            .map_err(|e| format!("Citations JSON error: {}", e))?;

        let mut citations = Vec::new();
        for cite_group in raw {
            let items: Vec<CitationItem> = cite_group
                .into_iter()
                .filter_map(|v| {
                    let id = v.get("id")?.as_str()?.to_string();
                    Some(CitationItem {
                        id,
                        locator: v
                            .get("locator")
                            .and_then(|l| l.as_str())
                            .map(|s| s.to_string()),
                        label: v
                            .get("label")
                            .and_then(|l| l.as_str())
                            .map(|s| s.to_string()),
                        prefix: v
                            .get("prefix")
                            .and_then(|p| p.as_str())
                            .map(|s| s.to_string()),
                        suffix: v
                            .get("suffix")
                            .and_then(|s| s.as_str())
                            .map(|s| s.to_string()),
                        ..Default::default()
                    })
                })
                .collect();

            if !items.is_empty() {
                citations.push(Citation {
                    items,
                    ..Default::default()
                });
            }
        }

        return Ok(citations);
    }

    // Check for citation-items
    if let Some(ref items_json) = test.citation_items {
        // Format: [[{"id": "ITEM-1"}, {"id": "ITEM-2"}]]
        let raw: Vec<Vec<serde_json::Value>> = serde_json::from_str(items_json)
            .map_err(|e| format!("Citation-items JSON error: {}", e))?;

        let mut citations = Vec::new();
        for cite_group in raw {
            let items: Vec<CitationItem> = cite_group
                .into_iter()
                .filter_map(|v| {
                    let id = v.get("id")?.as_str()?.to_string();
                    Some(CitationItem {
                        id,
                        locator: v
                            .get("locator")
                            .and_then(|l| l.as_str())
                            .map(|s| s.to_string()),
                        label: v
                            .get("label")
                            .and_then(|l| l.as_str())
                            .map(|s| s.to_string()),
                        prefix: v
                            .get("prefix")
                            .and_then(|p| p.as_str())
                            .map(|s| s.to_string()),
                        suffix: v
                            .get("suffix")
                            .and_then(|s| s.as_str())
                            .map(|s| s.to_string()),
                        ..Default::default()
                    })
                })
                .collect();

            if !items.is_empty() {
                citations.push(Citation {
                    items,
                    ..Default::default()
                });
            }
        }

        return Ok(citations);
    }

    // Default: create one citation with all references
    let items: Vec<CitationItem> = references
        .iter()
        .map(|r| CitationItem {
            id: r.id.clone(),
            ..Default::default()
        })
        .collect();

    Ok(vec![Citation {
        items,
        ..Default::default()
    }])
}

/// Format a bibliography entry with div wrapper.
fn format_bib_entry(entry: &str) -> String {
    format!("  <div class=\"csl-entry\">{}</div>", entry)
}

/// Format the complete bibliography with outer div.
fn format_bibliography(entries: &[String]) -> String {
    let mut output = String::from("<div class=\"csl-bib-body\">\n");
    for entry in entries {
        output.push_str(entry);
        output.push('\n');
    }
    output.push_str("</div>");
    output
}

/// Simple line-by-line diff for error messages.
fn simple_diff(expected: &str, actual: &str) -> String {
    let expected_lines: Vec<&str> = expected.lines().collect();
    let actual_lines: Vec<&str> = actual.lines().collect();

    let mut diff = String::new();
    let max_lines = expected_lines.len().max(actual_lines.len());

    for i in 0..max_lines {
        let exp = expected_lines.get(i).copied().unwrap_or("");
        let act = actual_lines.get(i).copied().unwrap_or("");

        if exp != act {
            diff.push_str(&format!("Line {}:\n", i + 1));
            diff.push_str(&format!("  - {}\n", exp));
            diff.push_str(&format!("  + {}\n", act));
        }
    }

    if diff.is_empty() {
        "No line differences (check trailing whitespace/newlines)".to_string()
    } else {
        diff
    }
}

// ============================================================================
// Generated Tests
// ============================================================================

// Include the generated tests
include!(concat!(env!("OUT_DIR"), "/generated_csl_tests.rs"));
