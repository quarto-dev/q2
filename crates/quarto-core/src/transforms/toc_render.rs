/*
 * toc_render.rs
 * Copyright (c) 2025 Posit, PBC
 *
 * Transform that renders TOC metadata to HTML.
 */

//! TOC rendering transform for HTML output.
//!
//! This transform reads the TOC structure from `navigation.toc` metadata
//! (generated by [`TocGenerateTransform`](super::TocGenerateTransform) or
//! provided by the user) and renders it to HTML, storing the result at
//! `rendered.navigation.toc`.
//!
//! ## Pipeline Position
//!
//! This transform should run after `TocGenerateTransform` (which creates
//! the `navigation.toc` structure) and before the template is applied.
//!
//! ## User Override
//!
//! Users can bypass this transform by providing their own pre-rendered
//! HTML at `rendered.navigation.toc` in the document metadata. The
//! transform detects this and skips rendering.
//!
//! ## HTML Output Structure
//!
//! The rendered HTML uses Bootstrap-compatible classes and attributes
//! for JavaScript scroll tracking:
//!
//! ```html
//! <ul>
//!   <li>
//!     <a href="#intro" class="nav-link" data-scroll-target="#intro">
//!       Introduction
//!     </a>
//!     <ul>
//!       <!-- nested entries -->
//!     </ul>
//!   </li>
//! </ul>
//! ```

use pampa::toc::{NavigationToc, TocEntry};
use quarto_pandoc_types::config_value::ConfigValue;
use quarto_pandoc_types::pandoc::Pandoc;
use quarto_source_map::SourceInfo;

use crate::Result;
use crate::render::RenderContext;
use crate::transform::AstTransform;

/// Transform that renders TOC to HTML.
///
/// This transform is format-specific (HTML). It reads the TOC structure
/// from metadata and renders it to HTML for template insertion.
pub struct TocRenderTransform;

impl TocRenderTransform {
    /// Create a new TOC render transform.
    pub fn new() -> Self {
        Self
    }
}

impl Default for TocRenderTransform {
    fn default() -> Self {
        Self::new()
    }
}

impl AstTransform for TocRenderTransform {
    fn name(&self) -> &str {
        "toc-render"
    }

    fn transform(&self, ast: &mut Pandoc, _ctx: &mut RenderContext) -> Result<()> {
        // Skip if already rendered (user provided pre-rendered HTML)
        if ast.meta.contains_path(&["rendered", "navigation", "toc"]) {
            return Ok(());
        }

        // Skip if no TOC data to render
        let Some(toc_data) = ast.meta.get_path(&["navigation", "toc"]) else {
            return Ok(());
        };

        // Parse the TOC structure
        let Some(toc) = NavigationToc::from_config_value(toc_data) else {
            return Ok(());
        };

        // Skip if no entries
        if toc.entries.is_empty() {
            return Ok(());
        }

        // Render to HTML
        let html = render_toc_entries_to_html(&toc.entries);

        // Store rendered HTML
        ast.meta.insert_path(
            &["rendered", "navigation", "toc"],
            ConfigValue::new_string(&html, SourceInfo::default()),
        );

        Ok(())
    }
}

/// Render TOC entries to HTML string (recursive).
fn render_toc_entries_to_html(entries: &[TocEntry]) -> String {
    if entries.is_empty() {
        return String::new();
    }

    let mut html = String::from("<ul>\n");
    for entry in entries {
        html.push_str("<li>\n");
        html.push_str(&format!(
            "<a href=\"#{}\" class=\"nav-link\" data-scroll-target=\"#{}\">\n",
            html_escape(&entry.id),
            html_escape(&entry.id)
        ));
        if let Some(ref number) = entry.number {
            html.push_str(&format!(
                "<span class=\"toc-number\">{}</span> ",
                html_escape(number)
            ));
        }
        html.push_str(&html_escape(&entry.title));
        html.push_str("\n</a>\n");

        if !entry.children.is_empty() {
            // Recursive call for nested entries
            html.push_str(&render_toc_entries_to_html(&entry.children));
        }
        html.push_str("</li>\n");
    }
    html.push_str("</ul>\n");
    html
}

/// Escape HTML special characters.
fn html_escape(s: &str) -> String {
    s.replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
        .replace('\'', "&#x27;")
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::format::Format;
    use crate::project::{DocumentInfo, ProjectContext};
    use crate::render::BinaryDependencies;
    use quarto_pandoc_types::config_value::ConfigValue;
    use std::path::PathBuf;

    fn dummy_source_info() -> SourceInfo {
        SourceInfo::default()
    }

    fn make_test_project() -> ProjectContext {
        ProjectContext {
            dir: PathBuf::from("/project"),
            config: None,
            is_single_file: true,
            files: vec![DocumentInfo::from_path("/project/doc.qmd")],
            output_dir: PathBuf::from("/project"),
        }
    }

    fn make_toc_entry(id: &str, title: &str, level: i32) -> TocEntry {
        TocEntry {
            id: id.to_string(),
            title: title.to_string(),
            level,
            number: None,
            children: vec![],
        }
    }

    #[test]
    fn test_transform_name() {
        let transform = TocRenderTransform::new();
        assert_eq!(transform.name(), "toc-render");
    }

    #[test]
    fn test_skips_when_no_toc_data() {
        let mut ast = Pandoc {
            meta: ConfigValue::default(),
            blocks: vec![],
        };

        let project = make_test_project();
        let doc = DocumentInfo::from_path("/project/doc.qmd");
        let format = Format::html();
        let binaries = BinaryDependencies::new();
        let mut ctx = RenderContext::new(&project, &doc, &format, &binaries);

        let transform = TocRenderTransform::new();
        transform.transform(&mut ast, &mut ctx).unwrap();

        // No rendered.navigation.toc should exist
        assert!(!ast.meta.contains_path(&["rendered", "navigation", "toc"]));
    }

    #[test]
    fn test_skips_when_already_rendered() {
        let mut ast = Pandoc {
            meta: ConfigValue::default(),
            blocks: vec![],
        };

        // Pre-populate with user-provided rendered HTML
        ast.meta.insert_path(
            &["rendered", "navigation", "toc"],
            ConfigValue::new_string("<ul><li>Custom</li></ul>", dummy_source_info()),
        );

        // Also add navigation.toc (would normally trigger rendering)
        let toc = NavigationToc {
            title: None,
            entries: vec![make_toc_entry("intro", "Introduction", 1)],
        };
        ast.meta
            .insert_path(&["navigation", "toc"], toc.to_config_value());

        let project = make_test_project();
        let doc = DocumentInfo::from_path("/project/doc.qmd");
        let format = Format::html();
        let binaries = BinaryDependencies::new();
        let mut ctx = RenderContext::new(&project, &doc, &format, &binaries);

        let transform = TocRenderTransform::new();
        transform.transform(&mut ast, &mut ctx).unwrap();

        // Should keep user-provided HTML
        let rendered = ast
            .meta
            .get_path(&["rendered", "navigation", "toc"])
            .unwrap();
        assert_eq!(rendered.as_str(), Some("<ul><li>Custom</li></ul>"));
    }

    #[test]
    fn test_renders_simple_toc() {
        let mut ast = Pandoc {
            meta: ConfigValue::default(),
            blocks: vec![],
        };

        let toc = NavigationToc {
            title: Some("Contents".to_string()),
            entries: vec![
                make_toc_entry("intro", "Introduction", 1),
                make_toc_entry("methods", "Methods", 1),
            ],
        };
        ast.meta
            .insert_path(&["navigation", "toc"], toc.to_config_value());

        let project = make_test_project();
        let doc = DocumentInfo::from_path("/project/doc.qmd");
        let format = Format::html();
        let binaries = BinaryDependencies::new();
        let mut ctx = RenderContext::new(&project, &doc, &format, &binaries);

        let transform = TocRenderTransform::new();
        transform.transform(&mut ast, &mut ctx).unwrap();

        // Should have rendered.navigation.toc
        assert!(ast.meta.contains_path(&["rendered", "navigation", "toc"]));

        let rendered = ast
            .meta
            .get_path(&["rendered", "navigation", "toc"])
            .unwrap();
        let html = rendered.as_str().unwrap();

        // Check structure
        assert!(html.contains("<ul>"));
        assert!(html.contains("</ul>"));
        assert!(html.contains("<li>"));
        assert!(html.contains("</li>"));
        assert!(html.contains("href=\"#intro\""));
        assert!(html.contains("href=\"#methods\""));
        assert!(html.contains("Introduction"));
        assert!(html.contains("Methods"));
        assert!(html.contains("class=\"nav-link\""));
        assert!(html.contains("data-scroll-target=\"#intro\""));
    }

    #[test]
    fn test_renders_nested_toc() {
        let mut ast = Pandoc {
            meta: ConfigValue::default(),
            blocks: vec![],
        };

        let toc = NavigationToc {
            title: None,
            entries: vec![TocEntry {
                id: "chapter".to_string(),
                title: "Chapter 1".to_string(),
                level: 1,
                number: None,
                children: vec![
                    make_toc_entry("section-a", "Section A", 2),
                    make_toc_entry("section-b", "Section B", 2),
                ],
            }],
        };
        ast.meta
            .insert_path(&["navigation", "toc"], toc.to_config_value());

        let project = make_test_project();
        let doc = DocumentInfo::from_path("/project/doc.qmd");
        let format = Format::html();
        let binaries = BinaryDependencies::new();
        let mut ctx = RenderContext::new(&project, &doc, &format, &binaries);

        let transform = TocRenderTransform::new();
        transform.transform(&mut ast, &mut ctx).unwrap();

        let rendered = ast
            .meta
            .get_path(&["rendered", "navigation", "toc"])
            .unwrap();
        let html = rendered.as_str().unwrap();

        // Check nested structure - there should be nested <ul> tags
        // Count occurrences of <ul>
        let ul_count = html.matches("<ul>").count();
        assert!(ul_count >= 2, "Should have nested <ul> tags");

        // Check all entries are present
        assert!(html.contains("Chapter 1"));
        assert!(html.contains("Section A"));
        assert!(html.contains("Section B"));
    }

    #[test]
    fn test_renders_toc_with_numbers() {
        let mut ast = Pandoc {
            meta: ConfigValue::default(),
            blocks: vec![],
        };

        let toc = NavigationToc {
            title: None,
            entries: vec![TocEntry {
                id: "intro".to_string(),
                title: "Introduction".to_string(),
                level: 1,
                number: Some("1".to_string()),
                children: vec![TocEntry {
                    id: "background".to_string(),
                    title: "Background".to_string(),
                    level: 2,
                    number: Some("1.1".to_string()),
                    children: vec![],
                }],
            }],
        };
        ast.meta
            .insert_path(&["navigation", "toc"], toc.to_config_value());

        let project = make_test_project();
        let doc = DocumentInfo::from_path("/project/doc.qmd");
        let format = Format::html();
        let binaries = BinaryDependencies::new();
        let mut ctx = RenderContext::new(&project, &doc, &format, &binaries);

        let transform = TocRenderTransform::new();
        transform.transform(&mut ast, &mut ctx).unwrap();

        let rendered = ast
            .meta
            .get_path(&["rendered", "navigation", "toc"])
            .unwrap();
        let html = rendered.as_str().unwrap();

        // Check section numbers are rendered
        assert!(html.contains("<span class=\"toc-number\">1</span>"));
        assert!(html.contains("<span class=\"toc-number\">1.1</span>"));
    }

    #[test]
    fn test_html_escape() {
        // Test that special characters are escaped
        assert_eq!(html_escape("a & b"), "a &amp; b");
        assert_eq!(html_escape("<script>"), "&lt;script&gt;");
        assert_eq!(html_escape("\"quoted\""), "&quot;quoted&quot;");
        assert_eq!(html_escape("it's"), "it&#x27;s");
    }

    #[test]
    fn test_renders_toc_escapes_special_chars() {
        let mut ast = Pandoc {
            meta: ConfigValue::default(),
            blocks: vec![],
        };

        let toc = NavigationToc {
            title: None,
            entries: vec![TocEntry {
                id: "intro-with-<script>".to_string(),
                title: "Title with <b>HTML</b> & \"quotes\"".to_string(),
                level: 1,
                number: None,
                children: vec![],
            }],
        };
        ast.meta
            .insert_path(&["navigation", "toc"], toc.to_config_value());

        let project = make_test_project();
        let doc = DocumentInfo::from_path("/project/doc.qmd");
        let format = Format::html();
        let binaries = BinaryDependencies::new();
        let mut ctx = RenderContext::new(&project, &doc, &format, &binaries);

        let transform = TocRenderTransform::new();
        transform.transform(&mut ast, &mut ctx).unwrap();

        let rendered = ast
            .meta
            .get_path(&["rendered", "navigation", "toc"])
            .unwrap();
        let html = rendered.as_str().unwrap();

        // Check that HTML is escaped
        assert!(html.contains("&lt;b&gt;HTML&lt;/b&gt;"));
        assert!(html.contains("&amp;"));
        assert!(html.contains("&quot;quotes&quot;"));
        assert!(html.contains("intro-with-&lt;script&gt;"));
    }

    #[test]
    fn test_skips_empty_entries() {
        let mut ast = Pandoc {
            meta: ConfigValue::default(),
            blocks: vec![],
        };

        let toc = NavigationToc {
            title: Some("Contents".to_string()),
            entries: vec![], // Empty entries
        };
        ast.meta
            .insert_path(&["navigation", "toc"], toc.to_config_value());

        let project = make_test_project();
        let doc = DocumentInfo::from_path("/project/doc.qmd");
        let format = Format::html();
        let binaries = BinaryDependencies::new();
        let mut ctx = RenderContext::new(&project, &doc, &format, &binaries);

        let transform = TocRenderTransform::new();
        transform.transform(&mut ast, &mut ctx).unwrap();

        // Should not have rendered.navigation.toc (empty entries)
        assert!(!ast.meta.contains_path(&["rendered", "navigation", "toc"]));
    }

    #[test]
    fn test_default_trait() {
        let _transform: TocRenderTransform = Default::default();
    }
}
