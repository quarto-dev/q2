/*
 * toc_render.rs
 * Copyright (c) 2025 Posit, PBC
 *
 * Transform that renders TOC metadata to HTML.
 */

//! TOC rendering transform for HTML output.
//!
//! This transform reads the TOC structure from `navigation.toc` metadata
//! (generated by [`TocGenerateTransform`](super::TocGenerateTransform) or
//! provided by the user) and renders it to HTML, storing the result at
//! `rendered.navigation.toc`.
//!
//! ## Pipeline Position
//!
//! This transform should run after `TocGenerateTransform` (which creates
//! the `navigation.toc` structure) and before the template is applied.
//!
//! ## User Override
//!
//! Users can bypass this transform by providing their own pre-rendered
//! HTML at `rendered.navigation.toc` in the document metadata. The
//! transform detects this and skips rendering.
//!
//! ## HTML Output Structure
//!
//! The rendered HTML uses Bootstrap-compatible classes and attributes
//! for JavaScript scroll tracking:
//!
//! ```html
//! <ul>
//!   <li>
//!     <a href="#intro" class="nav-link" data-scroll-target="#intro">
//!       Introduction
//!     </a>
//!     <ul>
//!       <!-- nested entries -->
//!     </ul>
//!   </li>
//! </ul>
//! ```

use pampa::toc::{NavigationToc, TocEntry};
use quarto_pandoc_types::config_value::ConfigValue;
use quarto_pandoc_types::pandoc::Pandoc;
use quarto_source_map::SourceInfo;

use crate::Result;
use crate::render::RenderContext;
use crate::transform::AstTransform;

/// Transform that renders TOC to HTML.
///
/// This transform is format-specific (HTML). It reads the TOC structure
/// from metadata and renders it to HTML for template insertion.
pub struct TocRenderTransform;

impl TocRenderTransform {
    /// Create a new TOC render transform.
    pub fn new() -> Self {
        Self
    }
}

impl Default for TocRenderTransform {
    fn default() -> Self {
        Self::new()
    }
}

impl AstTransform for TocRenderTransform {
    fn name(&self) -> &str {
        "toc-render"
    }

    fn transform(&self, ast: &mut Pandoc, _ctx: &mut RenderContext) -> Result<()> {
        // Skip if already rendered (user provided pre-rendered HTML)
        if ast.meta.contains_path(&["rendered", "navigation", "toc"]) {
            return Ok(());
        }

        // Skip if no TOC data to render
        let Some(toc_data) = ast.meta.get_path(&["navigation", "toc"]) else {
            return Ok(());
        };

        // Parse the TOC structure
        let Some(toc) = NavigationToc::from_config_value(toc_data) else {
            return Ok(());
        };

        // Skip if no entries
        if toc.entries.is_empty() {
            return Ok(());
        }

        // Render to HTML
        let html = render_toc_entries_to_html(&toc.entries);

        // Store rendered HTML
        ast.meta.insert_path(
            &["rendered", "navigation", "toc"],
            ConfigValue::new_string(&html, SourceInfo::default()),
        );

        Ok(())
    }
}

/// Render TOC entries to HTML string (recursive).
fn render_toc_entries_to_html(entries: &[TocEntry]) -> String {
    if entries.is_empty() {
        return String::new();
    }

    let mut html = String::from("<ul>\n");
    for entry in entries {
        html.push_str("<li>\n");
        html.push_str(&format!(
            "<a href=\"#{}\" class=\"nav-link\" data-scroll-target=\"#{}\">\n",
            html_escape(&entry.id),
            html_escape(&entry.id)
        ));
        if let Some(ref number) = entry.number {
            html.push_str(&format!(
                "<span class=\"toc-number\">{}</span> ",
                html_escape(number)
            ));
        }
        html.push_str(&html_escape(&entry.title));
        html.push_str("\n</a>\n");

        if !entry.children.is_empty() {
            // Recursive call for nested entries
            html.push_str(&render_toc_entries_to_html(&entry.children));
        }
        html.push_str("</li>\n");
    }
    html.push_str("</ul>\n");
    html
}

/// Escape HTML special characters.
fn html_escape(s: &str) -> String {
    s.replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
        .replace('\'', "&#x27;")
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::format::Format;
    use crate::project::{DocumentInfo, ProjectContext};
    use crate::render::BinaryDependencies;
    use quarto_pandoc_types::config_value::ConfigValue;
    use std::path::PathBuf;

    fn dummy_source_info() -> SourceInfo {
        SourceInfo::default()
    }

    fn make_test_project() -> ProjectContext {
        ProjectContext {
            dir: PathBuf::from("/project"),
            config: None,
            is_single_file: true,
            files: vec![DocumentInfo::from_path("/project/doc.qmd")],
            output_dir: PathBuf::from("/project"),
        }
    }

    fn make_toc_entry(id: &str, title: &str, level: i32) -> TocEntry {
        TocEntry {
            id: id.to_string(),
            title: title.to_string(),
            level,
            number: None,
            children: vec![],
        }
    }

    #[test]
    fn test_transform_name() {
        let transform = TocRenderTransform::new();
        assert_eq!(transform.name(), "toc-render");
    }

    #[test]
    fn test_skips_when_no_toc_data() {
        let mut ast = Pandoc {
            meta: ConfigValue::default(),
            blocks: vec![],
        };

        let project = make_test_project();
        let doc = DocumentInfo::from_path("/project/doc.qmd");
        let format = Format::html();
        let binaries = BinaryDependencies::new();
        let mut ctx = RenderContext::new(&project, &doc, &format, &binaries);

        let transform = TocRenderTransform::new();
        transform.transform(&mut ast, &mut ctx).unwrap();

        // No rendered.navigation.toc should exist
        assert!(!ast.meta.contains_path(&["rendered", "navigation", "toc"]));
    }

    #[test]
    fn test_skips_when_already_rendered() {
        let mut ast = Pandoc {
            meta: ConfigValue::default(),
            blocks: vec![],
        };

        // Pre-populate with user-provided rendered HTML
        ast.meta.insert_path(
            &["rendered", "navigation", "toc"],
            ConfigValue::new_string("<ul><li>Custom</li></ul>", dummy_source_info()),
        );

        // Also add navigation.toc (would normally trigger rendering)
        let toc = NavigationToc {
            title: None,
            entries: vec![make_toc_entry("intro", "Introduction", 1)],
        };
        ast.meta
            .insert_path(&["navigation", "toc"], toc.to_config_value());

        let project = make_test_project();
        let doc = DocumentInfo::from_path("/project/doc.qmd");
        let format = Format::html();
        let binaries = BinaryDependencies::new();
        let mut ctx = RenderContext::new(&project, &doc, &format, &binaries);

        let transform = TocRenderTransform::new();
        transform.transform(&mut ast, &mut ctx).unwrap();

        // Should keep user-provided HTML
        let rendered = ast
            .meta
            .get_path(&["rendered", "navigation", "toc"])
            .unwrap();
        assert_eq!(rendered.as_str(), Some("<ul><li>Custom</li></ul>"));
    }

    #[test]
    fn test_renders_simple_toc() {
        let mut ast = Pandoc {
            meta: ConfigValue::default(),
            blocks: vec![],
        };

        let toc = NavigationToc {
            title: Some("Contents".to_string()),
            entries: vec![
                make_toc_entry("intro", "Introduction", 1),
                make_toc_entry("methods", "Methods", 1),
            ],
        };
        ast.meta
            .insert_path(&["navigation", "toc"], toc.to_config_value());

        let project = make_test_project();
        let doc = DocumentInfo::from_path("/project/doc.qmd");
        let format = Format::html();
        let binaries = BinaryDependencies::new();
        let mut ctx = RenderContext::new(&project, &doc, &format, &binaries);

        let transform = TocRenderTransform::new();
        transform.transform(&mut ast, &mut ctx).unwrap();

        // Should have rendered.navigation.toc
        assert!(ast.meta.contains_path(&["rendered", "navigation", "toc"]));

        let rendered = ast
            .meta
            .get_path(&["rendered", "navigation", "toc"])
            .unwrap();
        let html = rendered.as_str().unwrap();

        // Check structure
        assert!(html.contains("<ul>"));
        assert!(html.contains("</ul>"));
        assert!(html.contains("<li>"));
        assert!(html.contains("</li>"));
        assert!(html.contains("href=\"#intro\""));
        assert!(html.contains("href=\"#methods\""));
        assert!(html.contains("Introduction"));
        assert!(html.contains("Methods"));
        assert!(html.contains("class=\"nav-link\""));
        assert!(html.contains("data-scroll-target=\"#intro\""));
    }

    #[test]
    fn test_renders_nested_toc() {
        let mut ast = Pandoc {
            meta: ConfigValue::default(),
            blocks: vec![],
        };

        let toc = NavigationToc {
            title: None,
            entries: vec![TocEntry {
                id: "chapter".to_string(),
                title: "Chapter 1".to_string(),
                level: 1,
                number: None,
                children: vec![
                    make_toc_entry("section-a", "Section A", 2),
                    make_toc_entry("section-b", "Section B", 2),
                ],
            }],
        };
        ast.meta
            .insert_path(&["navigation", "toc"], toc.to_config_value());

        let project = make_test_project();
        let doc = DocumentInfo::from_path("/project/doc.qmd");
        let format = Format::html();
        let binaries = BinaryDependencies::new();
        let mut ctx = RenderContext::new(&project, &doc, &format, &binaries);

        let transform = TocRenderTransform::new();
        transform.transform(&mut ast, &mut ctx).unwrap();

        let rendered = ast
            .meta
            .get_path(&["rendered", "navigation", "toc"])
            .unwrap();
        let html = rendered.as_str().unwrap();

        // Check nested structure - there should be nested <ul> tags
        // Count occurrences of <ul>
        let ul_count = html.matches("<ul>").count();
        assert!(ul_count >= 2, "Should have nested <ul> tags");

        // Check all entries are present
        assert!(html.contains("Chapter 1"));
        assert!(html.contains("Section A"));
        assert!(html.contains("Section B"));
    }

    #[test]
    fn test_renders_toc_with_numbers() {
        let mut ast = Pandoc {
            meta: ConfigValue::default(),
            blocks: vec![],
        };

        let toc = NavigationToc {
            title: None,
            entries: vec![TocEntry {
                id: "intro".to_string(),
                title: "Introduction".to_string(),
                level: 1,
                number: Some("1".to_string()),
                children: vec![TocEntry {
                    id: "background".to_string(),
                    title: "Background".to_string(),
                    level: 2,
                    number: Some("1.1".to_string()),
                    children: vec![],
                }],
            }],
        };
        ast.meta
            .insert_path(&["navigation", "toc"], toc.to_config_value());

        let project = make_test_project();
        let doc = DocumentInfo::from_path("/project/doc.qmd");
        let format = Format::html();
        let binaries = BinaryDependencies::new();
        let mut ctx = RenderContext::new(&project, &doc, &format, &binaries);

        let transform = TocRenderTransform::new();
        transform.transform(&mut ast, &mut ctx).unwrap();

        let rendered = ast
            .meta
            .get_path(&["rendered", "navigation", "toc"])
            .unwrap();
        let html = rendered.as_str().unwrap();

        // Check section numbers are rendered
        assert!(html.contains("<span class=\"toc-number\">1</span>"));
        assert!(html.contains("<span class=\"toc-number\">1.1</span>"));
    }

    #[test]
    fn test_html_escape() {
        // Test that special characters are escaped
        assert_eq!(html_escape("a & b"), "a &amp; b");
        assert_eq!(html_escape("<script>"), "&lt;script&gt;");
        assert_eq!(html_escape("\"quoted\""), "&quot;quoted&quot;");
        assert_eq!(html_escape("it's"), "it&#x27;s");
    }

    #[test]
    fn test_renders_toc_escapes_special_chars() {
        let mut ast = Pandoc {
            meta: ConfigValue::default(),
            blocks: vec![],
        };

        let toc = NavigationToc {
            title: None,
            entries: vec![TocEntry {
                id: "intro-with-<script>".to_string(),
                title: "Title with <b>HTML</b> & \"quotes\"".to_string(),
                level: 1,
                number: None,
                children: vec![],
            }],
        };
        ast.meta
            .insert_path(&["navigation", "toc"], toc.to_config_value());

        let project = make_test_project();
        let doc = DocumentInfo::from_path("/project/doc.qmd");
        let format = Format::html();
        let binaries = BinaryDependencies::new();
        let mut ctx = RenderContext::new(&project, &doc, &format, &binaries);

        let transform = TocRenderTransform::new();
        transform.transform(&mut ast, &mut ctx).unwrap();

        let rendered = ast
            .meta
            .get_path(&["rendered", "navigation", "toc"])
            .unwrap();
        let html = rendered.as_str().unwrap();

        // Check that HTML is escaped
        assert!(html.contains("&lt;b&gt;HTML&lt;/b&gt;"));
        assert!(html.contains("&amp;"));
        assert!(html.contains("&quot;quotes&quot;"));
        assert!(html.contains("intro-with-&lt;script&gt;"));
    }

    #[test]
    fn test_skips_empty_entries() {
        let mut ast = Pandoc {
            meta: ConfigValue::default(),
            blocks: vec![],
        };

        let toc = NavigationToc {
            title: Some("Contents".to_string()),
            entries: vec![], // Empty entries
        };
        ast.meta
            .insert_path(&["navigation", "toc"], toc.to_config_value());

        let project = make_test_project();
        let doc = DocumentInfo::from_path("/project/doc.qmd");
        let format = Format::html();
        let binaries = BinaryDependencies::new();
        let mut ctx = RenderContext::new(&project, &doc, &format, &binaries);

        let transform = TocRenderTransform::new();
        transform.transform(&mut ast, &mut ctx).unwrap();

        // Should not have rendered.navigation.toc (empty entries)
        assert!(!ast.meta.contains_path(&["rendered", "navigation", "toc"]));
    }

    #[test]
    fn test_default_trait() {
        let _transform: TocRenderTransform = Default::default();
    }

    // === Tests for user-provided metadata in YAML-parsed format ===
    //
    // These tests verify that TOC metadata provided by users in document
    // frontmatter is correctly parsed, even when YAML parsing converts
    // values to PandocInlines or string-encoded integers.

    use quarto_pandoc_types::config_value::ConfigMapEntry;
    use quarto_pandoc_types::inline::{Inline, Space, Str};

    /// Create a ConfigValue containing PandocInlines with a single Str.
    /// This simulates how YAML strings are parsed in document frontmatter.
    fn yaml_string_value(s: &str) -> ConfigValue {
        ConfigValue::new_inlines(
            vec![Inline::Str(Str {
                text: s.to_string(),
                source_info: SourceInfo::default(),
            })],
            SourceInfo::default(),
        )
    }

    /// Create a ConfigValue containing PandocInlines with multiple words.
    /// This simulates YAML strings with spaces like "The Details".
    fn yaml_multiword_string(words: &[&str]) -> ConfigValue {
        let mut inlines = Vec::new();
        for (i, word) in words.iter().enumerate() {
            if i > 0 {
                inlines.push(Inline::Space(Space {
                    source_info: SourceInfo::default(),
                }));
            }
            inlines.push(Inline::Str(Str {
                text: word.to_string(),
                source_info: SourceInfo::default(),
            }));
        }
        ConfigValue::new_inlines(inlines, SourceInfo::default())
    }

    /// Create a ConfigValue for a string-encoded integer.
    /// This simulates how YAML integers are sometimes parsed as strings.
    fn yaml_int_as_string(n: i32) -> ConfigValue {
        ConfigValue::new_string(&n.to_string(), SourceInfo::default())
    }

    /// Create a TOC entry ConfigValue in YAML-parsed format.
    fn yaml_toc_entry(id: &str, title: &str, level: i32) -> ConfigValue {
        ConfigValue::new_map(
            vec![
                ConfigMapEntry {
                    key: "id".to_string(),
                    key_source: SourceInfo::default(),
                    value: yaml_string_value(id),
                },
                ConfigMapEntry {
                    key: "title".to_string(),
                    key_source: SourceInfo::default(),
                    value: yaml_string_value(title),
                },
                ConfigMapEntry {
                    key: "level".to_string(),
                    key_source: SourceInfo::default(),
                    value: yaml_int_as_string(level),
                },
            ],
            SourceInfo::default(),
        )
    }

    /// Create a TOC entry with multiword title in YAML-parsed format.
    fn yaml_toc_entry_multiword(id: &str, title_words: &[&str], level: i32) -> ConfigValue {
        ConfigValue::new_map(
            vec![
                ConfigMapEntry {
                    key: "id".to_string(),
                    key_source: SourceInfo::default(),
                    value: yaml_string_value(id),
                },
                ConfigMapEntry {
                    key: "title".to_string(),
                    key_source: SourceInfo::default(),
                    value: yaml_multiword_string(title_words),
                },
                ConfigMapEntry {
                    key: "level".to_string(),
                    key_source: SourceInfo::default(),
                    value: yaml_int_as_string(level),
                },
            ],
            SourceInfo::default(),
        )
    }

    /// Create a TOC entry with children in YAML-parsed format.
    fn yaml_toc_entry_with_children(
        id: &str,
        title_words: &[&str],
        level: i32,
        children: Vec<ConfigValue>,
    ) -> ConfigValue {
        ConfigValue::new_map(
            vec![
                ConfigMapEntry {
                    key: "id".to_string(),
                    key_source: SourceInfo::default(),
                    value: yaml_string_value(id),
                },
                ConfigMapEntry {
                    key: "title".to_string(),
                    key_source: SourceInfo::default(),
                    value: yaml_multiword_string(title_words),
                },
                ConfigMapEntry {
                    key: "level".to_string(),
                    key_source: SourceInfo::default(),
                    value: yaml_int_as_string(level),
                },
                ConfigMapEntry {
                    key: "children".to_string(),
                    key_source: SourceInfo::default(),
                    value: ConfigValue::new_array(children, SourceInfo::default()),
                },
            ],
            SourceInfo::default(),
        )
    }

    #[test]
    fn test_renders_yaml_parsed_toc_simple() {
        // Simulates user-provided YAML:
        // navigation:
        //   toc:
        //     entries:
        //       - id: "tldr"
        //         title: "TL;DR"
        //         level: 1
        let mut ast = Pandoc {
            meta: ConfigValue::default(),
            blocks: vec![],
        };

        let toc_value = ConfigValue::new_map(
            vec![ConfigMapEntry {
                key: "entries".to_string(),
                key_source: SourceInfo::default(),
                value: ConfigValue::new_array(
                    vec![yaml_toc_entry("tldr", "TL;DR", 1)],
                    SourceInfo::default(),
                ),
            }],
            SourceInfo::default(),
        );
        ast.meta.insert_path(&["navigation", "toc"], toc_value);

        let project = make_test_project();
        let doc = DocumentInfo::from_path("/project/doc.qmd");
        let format = Format::html();
        let binaries = BinaryDependencies::new();
        let mut ctx = RenderContext::new(&project, &doc, &format, &binaries);

        let transform = TocRenderTransform::new();
        transform.transform(&mut ast, &mut ctx).unwrap();

        // Should have rendered TOC
        assert!(ast.meta.contains_path(&["rendered", "navigation", "toc"]));

        let rendered = ast
            .meta
            .get_path(&["rendered", "navigation", "toc"])
            .unwrap();
        let html = rendered.as_str().unwrap();

        assert!(html.contains("href=\"#tldr\""));
        assert!(html.contains("TL;DR"));
        assert!(html.contains("data-scroll-target=\"#tldr\""));
    }

    #[test]
    fn test_renders_yaml_parsed_toc_with_multiword_titles() {
        // Simulates user-provided YAML with multi-word titles:
        // navigation:
        //   toc:
        //     entries:
        //       - id: "details"
        //         title: "The Details"
        //         level: 1
        let mut ast = Pandoc {
            meta: ConfigValue::default(),
            blocks: vec![],
        };

        let toc_value = ConfigValue::new_map(
            vec![ConfigMapEntry {
                key: "entries".to_string(),
                key_source: SourceInfo::default(),
                value: ConfigValue::new_array(
                    vec![yaml_toc_entry_multiword("details", &["The", "Details"], 1)],
                    SourceInfo::default(),
                ),
            }],
            SourceInfo::default(),
        );
        ast.meta.insert_path(&["navigation", "toc"], toc_value);

        let project = make_test_project();
        let doc = DocumentInfo::from_path("/project/doc.qmd");
        let format = Format::html();
        let binaries = BinaryDependencies::new();
        let mut ctx = RenderContext::new(&project, &doc, &format, &binaries);

        let transform = TocRenderTransform::new();
        transform.transform(&mut ast, &mut ctx).unwrap();

        let rendered = ast
            .meta
            .get_path(&["rendered", "navigation", "toc"])
            .unwrap();
        let html = rendered.as_str().unwrap();

        assert!(html.contains("href=\"#details\""));
        assert!(html.contains("The Details"));
    }

    #[test]
    fn test_renders_yaml_parsed_toc_with_nested_children() {
        // Simulates user-provided YAML with nested structure:
        // navigation:
        //   toc:
        //     entries:
        //       - id: "details"
        //         title: "The Details"
        //         level: 1
        //         children:
        //           - id: "part-a"
        //             title: "Part A"
        //             level: 2
        let mut ast = Pandoc {
            meta: ConfigValue::default(),
            blocks: vec![],
        };

        let child_entry = yaml_toc_entry_multiword("part-a", &["Part", "A"], 2);
        let parent_entry =
            yaml_toc_entry_with_children("details", &["The", "Details"], 1, vec![child_entry]);

        let toc_value = ConfigValue::new_map(
            vec![ConfigMapEntry {
                key: "entries".to_string(),
                key_source: SourceInfo::default(),
                value: ConfigValue::new_array(vec![parent_entry], SourceInfo::default()),
            }],
            SourceInfo::default(),
        );
        ast.meta.insert_path(&["navigation", "toc"], toc_value);

        let project = make_test_project();
        let doc = DocumentInfo::from_path("/project/doc.qmd");
        let format = Format::html();
        let binaries = BinaryDependencies::new();
        let mut ctx = RenderContext::new(&project, &doc, &format, &binaries);

        let transform = TocRenderTransform::new();
        transform.transform(&mut ast, &mut ctx).unwrap();

        let rendered = ast
            .meta
            .get_path(&["rendered", "navigation", "toc"])
            .unwrap();
        let html = rendered.as_str().unwrap();

        // Check parent entry
        assert!(html.contains("href=\"#details\""));
        assert!(html.contains("The Details"));

        // Check child entry
        assert!(html.contains("href=\"#part-a\""));
        assert!(html.contains("Part A"));

        // Verify nested structure (two ul elements)
        let ul_count = html.matches("<ul>").count();
        assert!(
            ul_count >= 2,
            "Expected nested <ul> tags, found {}",
            ul_count
        );
    }

    #[test]
    fn test_user_provided_rendered_toc_used_directly() {
        // Simulates user providing pre-rendered HTML:
        // rendered:
        //   navigation:
        //     toc: "<ul><li>My Custom TOC</li></ul>"
        let mut ast = Pandoc {
            meta: ConfigValue::default(),
            blocks: vec![],
        };

        let custom_html = "<ul><li><a href=\"#custom\">My Custom TOC</a></li></ul>";
        ast.meta.insert_path(
            &["rendered", "navigation", "toc"],
            ConfigValue::new_string(custom_html, SourceInfo::default()),
        );

        // Also add navigation.toc that would normally be rendered
        let toc_value = ConfigValue::new_map(
            vec![ConfigMapEntry {
                key: "entries".to_string(),
                key_source: SourceInfo::default(),
                value: ConfigValue::new_array(
                    vec![yaml_toc_entry("intro", "Introduction", 1)],
                    SourceInfo::default(),
                ),
            }],
            SourceInfo::default(),
        );
        ast.meta.insert_path(&["navigation", "toc"], toc_value);

        let project = make_test_project();
        let doc = DocumentInfo::from_path("/project/doc.qmd");
        let format = Format::html();
        let binaries = BinaryDependencies::new();
        let mut ctx = RenderContext::new(&project, &doc, &format, &binaries);

        let transform = TocRenderTransform::new();
        transform.transform(&mut ast, &mut ctx).unwrap();

        // Should use user-provided HTML, not render from navigation.toc
        let rendered = ast
            .meta
            .get_path(&["rendered", "navigation", "toc"])
            .unwrap();
        assert_eq!(rendered.as_str(), Some(custom_html));

        // Verify it contains user content, not auto-rendered content
        let html = rendered.as_str().unwrap();
        assert!(html.contains("My Custom TOC"));
        assert!(!html.contains("Introduction")); // The navigation.toc entry should NOT appear
    }

    #[test]
    fn test_yaml_parsed_toc_with_title() {
        // Simulates user-provided YAML with TOC title:
        // navigation:
        //   toc:
        //     title: "Quick Links"
        //     entries:
        //       - id: "intro"
        //         title: "Introduction"
        //         level: 1
        let mut ast = Pandoc {
            meta: ConfigValue::default(),
            blocks: vec![],
        };

        let toc_value = ConfigValue::new_map(
            vec![
                ConfigMapEntry {
                    key: "title".to_string(),
                    key_source: SourceInfo::default(),
                    value: yaml_multiword_string(&["Quick", "Links"]),
                },
                ConfigMapEntry {
                    key: "entries".to_string(),
                    key_source: SourceInfo::default(),
                    value: ConfigValue::new_array(
                        vec![yaml_toc_entry("intro", "Introduction", 1)],
                        SourceInfo::default(),
                    ),
                },
            ],
            SourceInfo::default(),
        );
        ast.meta.insert_path(&["navigation", "toc"], toc_value);

        let project = make_test_project();
        let doc = DocumentInfo::from_path("/project/doc.qmd");
        let format = Format::html();
        let binaries = BinaryDependencies::new();
        let mut ctx = RenderContext::new(&project, &doc, &format, &binaries);

        let transform = TocRenderTransform::new();
        transform.transform(&mut ast, &mut ctx).unwrap();

        // Should have rendered TOC
        assert!(ast.meta.contains_path(&["rendered", "navigation", "toc"]));

        // The title is stored in navigation.toc.title for the template to use
        // (the render transform doesn't include it in the HTML output)
        let toc = ast.meta.get_path(&["navigation", "toc"]).unwrap();
        let title = toc.get("title").unwrap().as_plain_text().unwrap();
        assert_eq!(title, "Quick Links");
    }
}
