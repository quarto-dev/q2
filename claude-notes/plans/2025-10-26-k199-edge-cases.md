# Phase 3 Edge Cases Testing Plan (k-199)

**Date**: 2025-10-26
**Status**: Planning
**Owner**: Claude Code
**Parent Task**: k-192 (Phase 5: Write comprehensive tests for annotated Pandoc AST)
**Beads Issue**: k-199

## Objective

Ensure the annotated-qmd converters handle edge cases gracefully without errors or crashes. Validate that empty content, boundary conditions, and minimal structures produce valid AnnotatedParse output with correct source mapping.

## Current Context

After Phases 1-2:
- ✅ 91 tests passing
- ✅ DocumentConverter fully tested
- ✅ Complex documents tested (blog-post, academic-paper, tutorial)
- **Gap**: Edge cases not systematically tested

## Edge Case Categories

### Category 1: Empty Content
**Risk**: Arrays with `.map()` calls expect content. Empty arrays are valid but untested.

Test cases:
1. Empty paragraph (`Para` with empty inlines array)
2. Empty list items
3. Empty formatting (Emph/Strong with no content)
4. Empty code block (content = "")
5. Empty metadata ({})
6. Empty attributes (Attr = ["", [], []])

### Category 2: Minimal Documents
**Risk**: Boundary conditions around single elements or minimal structure.

Test cases:
1. Document with only metadata (no blocks)
2. Document with only one block (no metadata)
3. Single-item list (OrderedList/BulletList with one item)
4. Header with no content (just level, empty inlines)
5. Link with empty text
6. Table with single cell
7. DefinitionList with single definition

### Category 3: Boundary Values
**Risk**: Extreme but valid values that might break assumptions.

Test cases:
1. Header level 6 (maximum level)
2. Deeply nested lists (3+ levels) - already covered in Phase 2, but test isolation
3. Very long string in Str (1000+ chars)
4. Attr with many classes (10+ classes)
5. Empty string in Str ("")
6. OrderedList with start number != 1

### Category 4: Null and Missing Fields
**Risk**: Optional fields that might be undefined/null.

Test cases:
1. Missing optional fields (e.g., no caption on Table)
2. Null source info (should not happen, but defensive)
3. Missing attrS on blocks that have attributes
4. Empty target in Link ("", "")
5. MetaString with empty content

### Category 5: Source Mapping Edge Cases
**Risk**: Source tracking fails for empty or zero-width elements.

Test cases:
1. Empty Space element (zero-width)
2. SoftBreak/LineBreak (zero-width)
3. Empty metadata (start == end)
4. Concatenated empty strings
5. Element at file start (start = 0)
6. Element at file end (end = file.length)

## Implementation Plan

### Step 1: Create Test Fixtures (30 min)
Create minimal QMD files for edge cases:

1. **empty-content.qmd** (Category 1)
   ```markdown
   ---
   title: "Empty Content Test"
   ---



   -

   ```python
   ```
   ```

2. **minimal-doc.qmd** (Category 2)
   ```markdown
   ---
   title: "Minimal"
   ---

   One paragraph.
   ```

3. **boundary-values.qmd** (Category 3)
   ```markdown
   ###### Level 6 Header

   1. Item

   []{.class1 .class2 .class3}
   ```

4. **missing-fields.qmd** (Category 4)
   ```markdown
   []()

   | A |
   |---|
   | 1 |
   ```

5. **zero-width.qmd** (Category 5)
   ```markdown
   ---
   ---

   Word\
   Word
   ```

Generate JSON:
```bash
for f in empty-content minimal-doc boundary-values missing-fields zero-width; do
  cargo run --bin quarto-markdown-pandoc -- -t json -i examples/$f.qmd 2>/dev/null > examples/$f.json
done
```

### Step 2: Create test/edge-cases.test.ts (90 min)

Structure:
```typescript
describe('Edge Cases', () => {

  describe('Empty Content', () => {
    test('empty paragraph produces valid AnnotatedParse');
    test('empty list items produce valid structure');
    test('empty formatting elements work');
    test('empty code block has correct source');
    test('empty metadata produces valid mapping');
    test('empty attributes handled correctly');
  });

  describe('Minimal Documents', () => {
    test('document with only metadata');
    test('document with only one block');
    test('single-item list');
    test('header with minimal content');
    test('link with empty text');
    test('table with single cell');
    test('definition list with one item');
  });

  describe('Boundary Values', () => {
    test('header level 6 (maximum)');
    test('very long Str content (1000+ chars)');
    test('attr with many classes');
    test('empty string in Str');
    test('ordered list start number != 1');
  });

  describe('Null and Missing Fields', () => {
    test('table without caption');
    test('missing attrS handled gracefully');
    test('link with empty target');
    test('MetaString with empty content');
  });

  describe('Source Mapping Edge Cases', () => {
    test('Space element has valid source range');
    test('SoftBreak element has valid source range');
    test('LineBreak element has valid source range');
    test('empty metadata has valid range');
    test('element at file start (offset 0)');
    test('element at file end');
  });
});
```

### Step 3: Validation Helpers (30 min)

Create reusable validators:
```typescript
/**
 * Validate that AnnotatedParse has required fields
 */
function validateAnnotatedParse(node: AnnotatedParse): void {
  assert.ok('kind' in node, 'Should have kind');
  assert.ok('source' in node, 'Should have source');
  assert.ok('components' in node, 'Should have components');
  assert.ok('start' in node, 'Should have start');
  assert.ok('end' in node, 'Should have end');
  assert.ok('result' in node, 'Should have result');

  // Source should be valid
  assert.ok(node.source !== undefined, 'source should not be undefined');

  // Offsets should be valid
  assert.ok(node.start >= 0, 'start should be >= 0');
  assert.ok(node.end >= node.start, 'end should be >= start');

  // Components should be array
  assert.ok(Array.isArray(node.components), 'components should be array');
}

/**
 * Validate that empty content produces empty components
 */
function validateEmptyContent(node: AnnotatedParse): void {
  validateAnnotatedParse(node);
  assert.equal(node.components.length, 0, 'Empty content should have 0 components');
}

/**
 * Validate source mapping is within file bounds
 */
function validateSourceBounds(node: AnnotatedParse, fileLength: number): void {
  assert.ok(node.start >= 0 && node.start <= fileLength,
    `start ${node.start} should be in bounds [0, ${fileLength}]`);
  assert.ok(node.end >= 0 && node.end <= fileLength,
    `end ${node.end} should be in bounds [0, ${fileLength}]`);
}
```

### Step 4: Test Execution (30 min)

For each test:
1. Load fixture with `loadExample()`
2. Convert to AnnotatedParse
3. Run validators
4. Make specific assertions for the edge case
5. Verify no errors/exceptions thrown

Example test:
```typescript
test('empty paragraph produces valid AnnotatedParse', () => {
  const json = loadExample('empty-content');
  const doc = parseRustQmdDocument(json);

  // Find empty Para
  const paras = findNodesByKind(doc, 'Para');
  const emptyPara = paras.find(p => p.components.length === 0);

  assert.ok(emptyPara, 'Should find empty Para');
  validateAnnotatedParse(emptyPara!);
  validateEmptyContent(emptyPara!);

  // Should still have valid source range
  assert.ok(emptyPara!.end > emptyPara!.start, 'Should have non-zero source range');
});
```

### Step 5: Run and Verify (15 min)

```bash
npm test
```

Expected result: ~25-30 new tests, all passing.

## Success Criteria

✅ At least 25 edge case tests written
✅ All 5 categories covered
✅ All tests pass without errors
✅ Validators ensure structural validity
✅ Source mapping works for edge cases
✅ Empty content handled gracefully
✅ No uncaught exceptions or crashes

## Risk Assessment

**Low Risk**:
- Empty arrays: Likely already work due to `.map()` behavior
- Missing optional fields: Code has defensive checks

**Medium Risk**:
- Source mapping for zero-width elements (Space, LineBreak)
- Empty metadata edge cases (start == end)

**If tests fail**:
1. Document the failure in k-199
2. Create new beads issues for bugs found
3. Use TDD: keep failing test, fix code, verify pass

## Estimated Effort

- Fixture creation: 30 min
- Test file creation: 90 min
- Validator helpers: 30 min
- Test execution & verification: 15 min
- **Total: ~2.5 hours**

## Dependencies

- Phases 1-2 completed ✅
- `loadExample()` helper from complex-documents.test.ts
- `findNodesByKind()` helper from complex-documents.test.ts
- `parseRustQmdDocument()` function from src/index.js

## Deliverables

1. 5 new QMD fixtures (examples/empty-content.qmd, etc.)
2. 5 new JSON fixtures
3. test/edge-cases.test.ts with ~25-30 tests
4. Validation helper functions
5. Documentation of any bugs found

## Notes

- This phase focuses on **defensive validation**, not fixing bugs
- If bugs are found, create separate beads issues (don't fix inline)
- All tests should validate graceful degradation
- Empty content is **valid** and should produce valid AnnotatedParse structures
- Use TDD: write test, verify it runs without crashing, make assertions

## Next Steps After Phase 3

If Phase 3 completes successfully:
- Consider Phase 4 (k-228): Components tree validation
- Consider Phase 5 (k-229): Performance baseline (optional)
- Close k-192 if Phases 1-3 satisfy requirements
